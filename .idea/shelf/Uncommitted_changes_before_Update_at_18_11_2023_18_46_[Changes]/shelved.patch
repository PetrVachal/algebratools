Index: algexptools/variablealgexp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC, abstractmethod\r\nfrom copy import deepcopy\r\nimport re\r\nfrom typing import Any, List, Tuple\r\n\r\nfrom algebradata import AlgebraData as Ad\r\nfrom algexptools import AlgExp\r\nfrom errormessages import ErrorMessages\r\n\r\n\r\nclass VariableAlgExp(AlgExp, ABC):\r\n    \"\"\"\r\n    Abstract class for algebraic expressions that contain at least one variable.\r\n    - VariableAtomicAlgExp       variable expression without operations\r\n    - VariableCompositeAlgExp    variable expression with operations\r\n    \"\"\"\r\n    _PREFIX: str = \"VariableAlgExp\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # common variables\r\n    _immutable_contents: dict = None\r\n    _variables_domains: dict = None\r\n\r\n    def __init__(self, expression: Any, variables_domains: dict = None):\r\n        super().__init__(expression)\r\n        self.__create_variable_domains(expression, variables_domains)\r\n        self.__create_immutable_contents(expression)\r\n\r\n    @abstractmethod\r\n    def _found_and_get_all_variables(self) -> list:\r\n        \"\"\"\r\n        Returns list of all variables in self-expression.\r\n        :return: list of all variables in self-expression\r\n        \"\"\"\r\n        return NotImplemented\r\n\r\n    @property\r\n    def immutable_contents(self):\r\n        return self._immutable_contents\r\n\r\n    @property\r\n    def variables(self):\r\n        return self._found_and_get_all_variables()\r\n\r\n    @property\r\n    def variables_domains(self) -> dict:\r\n        return self._variables_domains\r\n\r\n    def _correction(self, expression: str) -> str:\r\n        # substitution for immutable contents\r\n        immutable_contents: dict = self.__found_and_get_immutable_contents(expression)\r\n        expression = self.__substitute_immutable_areas(expression, immutable_contents)\r\n        expression = super()._correction(expression)\r\n        # reverse substitution to the original content\r\n        expression = self.__substitute_immutable_areas(expression, immutable_contents, reverse=True)\r\n        return expression\r\n\r\n    def _create_content_from_other_instance(self, expression):\r\n        super()._create_content_from_other_instance(expression)\r\n\r\n    def _init_check(self, expression: Any, variables_domains: dict = None) -> None:\r\n        left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET\r\n        new_asserts: list = [\r\n            (isinstance(variables_domains, dict) or variables_domains is None,\r\n             \"variables_domains must be dict or None\"),\r\n            (not isinstance(expression, str) or expression.count(left_imm_br) == expression.count(right_imm_br),\r\n             f\"The numbers of '{left_imm_br}' and '{right_imm_br}' brackets must be the same.\"),\r\n        ]\r\n        self._asserts += new_asserts\r\n        super()._init_check(expression)\r\n\r\n    def _replace_immutable_areas(self, expression: str, replace_character: str = Ad.SUBSTITUTION_CHARACTER) -> str:\r\n        \"\"\"\r\n        Replaces all characters in immutable areas with replace_character.\r\n        :param expression: any algebraic expression\r\n        :param replace_character: any character [#]\r\n        :return: expression that has all characters in immutable areas replaced\r\n        \"\"\"\r\n        areas: list = self.__get_immutable_content_areas(expression)\r\n        expression_list: list = list(expression)\r\n        for area in areas:\r\n            start_index, end_index = area\r\n            for i in range(start_index, end_index + 1):\r\n                expression_list[i] = replace_character\r\n        return \"\".join(expression_list)\r\n\r\n    def __create_immutable_contents(self, expression: Any) -> None:\r\n        \"\"\"\r\n        Creates substitution dictionary named as immutable_contents for all immutable\r\n        contents of expression and stores this dictionary in self variable.\r\n        :param expression: any algebraic expression\r\n        :return: None\r\n        \"\"\"\r\n        if isinstance(expression, VariableAlgExp):\r\n            self._immutable_contents = deepcopy(expression.immutable_contents)\r\n            return\r\n        self._immutable_contents = deepcopy(self.__found_and_get_immutable_contents(expression))\r\n\r\n    def __create_variable_domains(self, expression: Any, variables_domains: dict | None) -> None:\r\n        \"\"\"\r\n        Creates variable domains for all variable in expression.\r\n        :param expression: any algebraic expression\r\n        :param variables_domains: predefined domains or None\r\n        :return: None\r\n        \"\"\"\r\n        if variables_domains is None:\r\n            if isinstance(expression, str):\r\n                self._variables_domains = self.__generate_default_variables_domains()\r\n            elif isinstance(expression, VariableAlgExp):\r\n                self._variables_domains = deepcopy(expression.variables_domains)\r\n        else:\r\n            self.__check_variables_domains(variables_domains)\r\n            self._variables_domains = deepcopy(variables_domains)\r\n\r\n    def __found_and_get_immutable_contents(self, expression: str) -> dict:\r\n        \"\"\"\r\n        Creates substitution dictionary for all immutable contents of expression.\r\n        :param expression: any algebraic expression\r\n        :return: substitution dictionary for all immutable contents of expression\r\n        \"\"\"\r\n        immutable_areas: list = self.__get_immutable_content_areas(expression)\r\n        immutable_contents: dict = {}\r\n        for area in immutable_areas:\r\n            start_index, end_index = area\r\n            actual_content = expression[start_index: end_index + 1]\r\n            if actual_content not in immutable_contents:\r\n                immutable_contents[actual_content] = f\"{Ad.SUBSTITUTION_CHARACTER}{self._substitution_index}\"\r\n                self._substitution_index += 1\r\n        return immutable_contents\r\n\r\n    def __generate_default_variables_domains(self) -> dict:\r\n        \"\"\"\r\n        Creates default variable domains for all variables in self-expression.\r\n        Default variable domain for every variable is in this case open interval (-inf, inf).\r\n        :return: default variable domains for all variables in self-expression\r\n        \"\"\"\r\n        from algsettools import IntervalAlgSet\r\n        return {variable: IntervalAlgSet() for variable in self.variables}\r\n\r\n    def __get_immutable_content_areas(self, expression: str) -> list:\r\n        \"\"\"\r\n        Searches immutable content areas in expression and after that, returns these areas.\r\n        This is very dirty work method.\r\n        No grandeur, no abstraction. Just plain prehistoric index butchery.\r\n        This method is in its ground-work, at the very bottom. This method is truly priceless.\r\n        :param expression: any algebraic expression\r\n        :return: all immutable contents areas for expression\r\n        \"\"\"\r\n        left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET\r\n        analyzed_brackets: List[Tuple[str, str]] = [(left_imm_br, right_imm_br)]\r\n        bracketing: list = self._bracketing(expression, analyzed_brackets)\r\n        areas: list = []\r\n        start_index, end_index = -1, -1\r\n        is_deep_level: bool = False\r\n        for i, deep_level in enumerate(bracketing):\r\n            if deep_level == 1 and not is_deep_level:\r\n                # start of new area\r\n                start_index = i + 1\r\n                is_deep_level = True\r\n                continue\r\n            if deep_level == 0 and is_deep_level:\r\n                # end of current area\r\n                end_index = i - 1\r\n                if start_index == -1:\r\n                    is_not_variable: str = ErrorMessages.replace(ErrorMessages.IS_NOT_VARIABLE, expression)\r\n                    raise ValueError(f\"{self._ERR}{is_not_variable}\")\r\n                if start_index <= end_index:\r\n                    areas.append((start_index, end_index))\r\n                is_deep_level = False\r\n                continue\r\n        return areas\r\n\r\n    def __check_variables_domains(self, variables_domains: dict) -> None:\r\n        \"\"\"\r\n        Checks whether any set from variable domains is not an empty set.\r\n        If such a set is found, it throws an exception.\r\n        :param variables_domains: variable domains for all variables in expression\r\n        :return: None\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet\r\n        for variable, alg_set in variables_domains.items():\r\n            if isinstance(alg_set, DiscreteAlgSet):\r\n                var_has_empty_domain: str = ErrorMessages.replace(ErrorMessages.VAR_HAS_EMPTY_SET_DOMAIN, variable)\r\n                assert not alg_set.is_empty(), f\"{self._ERR}{var_has_empty_domain}\"\r\n\r\n    def __substitute_immutable_areas(self, expression: str, immutable_contents: dict, reverse: bool = False) -> str:\r\n        \"\"\"\r\n        Substitutes all immutable areas in expression.\r\n        :param expression: any algebraic expression\r\n        :param immutable_contents: all immutable contents of expression\r\n        :param reverse: flag for reverse substitution\r\n        :return: expression with substituted immutable areas\r\n        \"\"\"\r\n        left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET\r\n        if reverse:\r\n            immutable_contents: dict = {sub_id: content for (content, sub_id) in immutable_contents.items()}\r\n            self._substitution_index = 1\r\n        for key in immutable_contents:\r\n            expression = expression.replace(f\"{left_imm_br}{key}{right_imm_br}\",\r\n                                            f\"{left_imm_br}{immutable_contents[key]}{right_imm_br}\")\r\n        return expression\r\n\r\n    @staticmethod\r\n    def substituted(alg_exp, subs_dict: dict):\r\n        \"\"\"\r\n        Returns new instance of VariableAlgExp with substituted variables\r\n        based on substitution dictionary.\r\n        :param alg_exp: any variable algebraic expression\r\n        :param subs_dict: dictionary with {key: value} <=> {variable: number to substitute}\r\n        :return: instance of AlgExp\r\n        \"\"\"\r\n        new_instance = deepcopy(alg_exp)\r\n        must_be_instance: str = ErrorMessages.replace(ErrorMessages.EXP_MUST_BE_INSTANCE, VariableAlgExp.__name__)\r\n        assert isinstance(alg_exp, VariableAlgExp), f\"{AlgExp._ERR}{must_be_instance}\"\r\n        for variable in subs_dict:\r\n            if variable in new_instance:\r\n                type(new_instance)._substitute(new_instance, variable, subs_dict[variable])\r\n        exp_result = AlgExp.initializer(str(new_instance))\r\n        del new_instance  # this instance may contain conflicting data, it served only for content substitution\r\n        return exp_result\r\n\r\n    @staticmethod\r\n    def _substitute(alg_exp, variable: str, number: Any):\r\n        \"\"\"\r\n        Returns alg_exp with variable substituted for number.\r\n        :param alg_exp: any variable algebraic expression\r\n        :param variable: variable which will be substituted\r\n        :param number: number for substitute\r\n        :return: alg_exp with substituted content\r\n        \"\"\"\r\n        allowed_subs_types: tuple = (int, str)\r\n        types_names: str = \" | \".join([x.__name__ for x in allowed_subs_types])\r\n        must_be_instance: str = ErrorMessages.replace(ErrorMessages.NUMBER_MUST_BE_INSTANCE, types_names)\r\n        assert isinstance(number, allowed_subs_types), f\"{VariableAlgExp._ERR}{must_be_instance}\"\r\n        if isinstance(number, str):\r\n            assert re.search(rf\"{Ad.MINUS}?\\d+\", number), f\"{AlgExp._ERR}{ErrorMessages.MUST_BE_INTEGER}\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algexptools/variablealgexp.py b/algexptools/variablealgexp.py
--- a/algexptools/variablealgexp.py	(revision e0ae38b29b3dbfb62d4685580ce6bac30e683b6c)
+++ b/algexptools/variablealgexp.py	(date 1700328338661)
@@ -109,8 +109,12 @@
             elif isinstance(expression, VariableAlgExp):
                 self._variables_domains = deepcopy(expression.variables_domains)
         else:
+            from algsettools import IntervalAlgSet
             self.__check_variables_domains(variables_domains)
             self._variables_domains = deepcopy(variables_domains)
+            unspecified_variables: list = list(set(self.variables) - set(variables_domains))
+            for unspecified_variable in unspecified_variables:
+                self._variables_domains[unspecified_variable] = IntervalAlgSet()
 
     def __found_and_get_immutable_contents(self, expression: str) -> dict:
         """
@@ -162,7 +166,8 @@
                 # end of current area
                 end_index = i - 1
                 if start_index == -1:
-                    is_not_variable: str = ErrorMessages.replace(ErrorMessages.IS_NOT_VARIABLE, expression)
+                    is_not_variable: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression,
+                                                                 VariableAlgExp.__name__)
                     raise ValueError(f"{self._ERR}{is_not_variable}")
                 if start_index <= end_index:
                     areas.append((start_index, end_index))
@@ -209,13 +214,19 @@
         :param subs_dict: dictionary with {key: value} <=> {variable: number to substitute}
         :return: instance of AlgExp
         """
+        must_be_instance: str = ErrorMessages.replace(ErrorMessages.MUST_BE_INSTANCE, "Expression",
+                                                      VariableAlgExp.__name__)
+        assert isinstance(alg_exp, VariableAlgExp), f"{AlgExp._ERR}{must_be_instance}"
         new_instance = deepcopy(alg_exp)
-        must_be_instance: str = ErrorMessages.replace(ErrorMessages.EXP_MUST_BE_INSTANCE, VariableAlgExp.__name__)
-        assert isinstance(alg_exp, VariableAlgExp), f"{AlgExp._ERR}{must_be_instance}"
+        new_variables_domains: dict = deepcopy(new_instance.variables_domains)
         for variable in subs_dict:
             if variable in new_instance:
                 type(new_instance)._substitute(new_instance, variable, subs_dict[variable])
-        exp_result = AlgExp.initializer(str(new_instance))
+                del new_variables_domains[variable]
+        if new_variables_domains:
+            exp_result = type(new_instance)(str(new_instance), new_variables_domains)
+        else:
+            exp_result = AlgExp.initializer(str(new_instance))
         del new_instance  # this instance may contain conflicting data, it served only for content substitution
         return exp_result
 
@@ -230,7 +241,7 @@
         """
         allowed_subs_types: tuple = (int, str)
         types_names: str = " | ".join([x.__name__ for x in allowed_subs_types])
-        must_be_instance: str = ErrorMessages.replace(ErrorMessages.NUMBER_MUST_BE_INSTANCE, types_names)
+        must_be_instance: str = ErrorMessages.replace(ErrorMessages.MUST_BE_INSTANCE, "number", types_names)
         assert isinstance(number, allowed_subs_types), f"{VariableAlgExp._ERR}{must_be_instance}"
         if isinstance(number, str):
             assert re.search(rf"{Ad.MINUS}?\d+", number), f"{AlgExp._ERR}{ErrorMessages.MUST_BE_INTEGER}"
Index: algexptools/algexp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC, abstractmethod\r\nfrom inspect import isabstract\r\nimport re\r\nfrom typing import Any, Tuple\r\n\r\nfrom algebradata import AlgebraData as Ad\r\nfrom errormessages import ErrorMessages\r\nfrom patterns import Patterns\r\n\r\n\r\nclass AlgExp(ABC):\r\n    \"\"\"\r\n    Abstract class for all kinds of algebraic expressions:\r\n\r\n    - NumericAtomicAlgExp     numeric expression without operations\r\n    - NumericCompositeAlgExp  numeric expression with operations\r\n    - VariableAtomicAlgExp    variable expression without operations\r\n    - VariableCompositeAlgExp variable expression with operations\r\n    \"\"\"\r\n    _PREFIX: str = \"AlgExp\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # common variables\r\n    _content: list | str = None\r\n\r\n    # other variables\r\n    _allowed_content_pattern: re = None\r\n    _allowed_types: dict = None\r\n    _asserts: list = None\r\n    _correction_methods: tuple = None\r\n    _special_numeric_strings_substitutions: dict = None\r\n    _substitution_index: int = None\r\n\r\n    def __init__(self, expression: Any):\r\n        self._correction_methods = (self._remove_white_spaces, self._remove_redundant_pluses_minuses,\r\n                                    self._remove_outer_brackets) + self._correction_methods\r\n        self._special_numeric_strings_substitutions = {}\r\n        self._substitution_index = 1\r\n        self._init_check(expression)\r\n        self._create_content(expression)\r\n\r\n    @abstractmethod\r\n    def __str__(self):\r\n        return NotImplemented\r\n\r\n    @abstractmethod\r\n    def has_imag(self) -> bool:\r\n        \"\"\"\r\n        If expression contains an imaginary unit, returns True.\r\n        Otherwise, returns False.\r\n        :return: see doc\r\n        \"\"\"\r\n        return NotImplemented\r\n\r\n    @abstractmethod\r\n    def _create_content_from_str(self, expression: str):\r\n        \"\"\"\r\n        Creates specific structure (named as content) from an expression string.\r\n        :param expression: any algebraic expression\r\n        :return: None\r\n        \"\"\"\r\n        return NotImplemented\r\n\r\n    def __add__(self, other):\r\n        return self.__magic_operation_method_result(other, Ad.PLUS)\r\n\r\n    def __contains__(self, item: int | str):\r\n        assert isinstance(item, (int, str)), f\"{self._ERR}{ErrorMessages.TYPE_FOR_ITEM_IN_CONTAINS}\"\r\n\r\n    def __mul__(self, other):\r\n        return self.__magic_operation_method_result(other, Ad.MULTIPLY)\r\n\r\n    def __neg__(self):\r\n        from algexptools import AtomicAlgExp\r\n        if isinstance(self, AtomicAlgExp):\r\n            return AlgExp.initializer(f\"{Ad.MINUS}{self}\")\r\n        return AlgExp.initializer(f\"{Ad.MINUS}{Ad.LEFT_BRACKET}{self}{Ad.RIGHT_BRACKET}\")\r\n\r\n    def __pos__(self):\r\n        return AlgExp.initializer(self)\r\n\r\n    def __pow__(self, power, modulo=None):\r\n        return self.__magic_operation_method_result(power, Ad.POWER)\r\n\r\n    def __radd__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__add__)\r\n\r\n    def __repr__(self):\r\n        return str(self)\r\n\r\n    def __rmul__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__mul__)\r\n\r\n    def __rpow__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__pow__)\r\n\r\n    def __rsub__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__sub__)\r\n\r\n    def __rtruediv__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__truediv__)\r\n\r\n    def __sub__(self, other):\r\n        return self.__magic_operation_method_result(other, Ad.MINUS)\r\n\r\n    def __truediv__(self, other):\r\n        return self.__magic_operation_method_result(other, Ad.DIV)\r\n\r\n    @property\r\n    def content(self):\r\n        return self._content\r\n\r\n    def _correction(self, expression: str) -> str:\r\n        \"\"\"\r\n        With the correction methods given for each instance, it corrects\r\n        the string expression to create content.\r\n        :param expression: any algebraic expression\r\n        :return: string expression in the correct format to create content\r\n        \"\"\"\r\n        # substitute all special numeric strings\r\n        expression = self._substitute_all_special_numeric_strings(expression)\r\n        original_expression: str = \"\"\r\n        while expression != original_expression:\r\n            original_expression = expression\r\n            for method in self._correction_methods:\r\n                expression = method(expression)\r\n        # reverse substitute all special numeric strings\r\n        expression = self._substitute_all_special_numeric_strings(expression, reverse=True)\r\n        return expression\r\n\r\n    def _create_content(self, expression: Any) -> None:\r\n        \"\"\"\r\n        Creates content based one the type of an algebraic expression.\r\n        :param expression: any algebraic expression\r\n        :return: None\r\n        \"\"\"\r\n        self._allowed_types[type(expression)](expression)\r\n\r\n    def _create_content_from_other_instance(self, expression) -> None:\r\n        \"\"\"\r\n        Creates content from other instance of an algebraic expression.\r\n        :param expression: any algebraic expression\r\n        :return: None\r\n        \"\"\"\r\n        must_be_instance: str = ErrorMessages.replace(ErrorMessages.EXP_MUST_BE_INSTANCE, self.__class__)\r\n        assert isinstance(expression, self.__class__), f\"{self._ERR}{must_be_instance}\"\r\n        self._content = expression.content\r\n\r\n    def _init_check(self, expression: Any, variables_domains: dict = None) -> None:\r\n        \"\"\"\r\n        Sniper filter for throwing an exception if the parameters are invalid.\r\n        :param expression: any algebraic expression\r\n        :param variables_domains: definition domains of variables\r\n        :return: None\r\n        \"\"\"\r\n        left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET\r\n        new_allowed_types: dict = {str: self._create_content_from_str,\r\n                                   self.__class__: self._create_content_from_other_instance}\r\n        self._allowed_types.update(new_allowed_types)\r\n        types_string: str = \"(\" + \", \".join([x.__name__ for x in self._allowed_types]) + \")\"\r\n        new_asserts: list = [\r\n            (isinstance(expression, tuple(self._allowed_types)),\r\n             f\"expression must be in {types_string}\"),\r\n            (not isinstance(expression, str) or expression.count(left_br) == expression.count(right_br),\r\n             f\"The numbers of '{left_br}' and '{right_br}' brackets must be the same.\"),\r\n        ]\r\n        self._asserts += new_asserts\r\n        for condition, err_message in self._asserts:\r\n            assert condition, f\"{self._ERR}{err_message}\"\r\n\r\n    def _is_wrapped_in_brackets(self, expression: str, left_br: str = Ad.LEFT_BRACKET,\r\n                                right_br: str = Ad.RIGHT_BRACKET) -> bool:\r\n        \"\"\"\r\n        Returns True if the whole expression is wrapped in brackets.\r\n        Otherwise, returns False.\r\n        :param expression: any algebraic expression\r\n        :param left_br: some type of left bracket\r\n        :param right_br: some type of right bracket\r\n        :return: see doc\r\n        \"\"\"\r\n        analyzed_brackets: list = [(left_br, right_br)]\r\n        if len(expression) > 2 and self._bracketing(expression, analyzed_brackets).count(0) == 1:\r\n            return True\r\n        return False\r\n\r\n    def _remove_outer_brackets(self, expression: str) -> str:\r\n        \"\"\"\r\n        Returns an expression without unnecessary brackets.\r\n        :param expression: any algebraic expression\r\n        :return: see doc\r\n        \"\"\"\r\n        while self._is_wrapped_in_brackets(expression):\r\n            expression = expression[1:-1]\r\n        return expression\r\n\r\n    def _substitute_all_special_numeric_strings(self, expression: str, reverse: bool = False) -> str:\r\n        \"\"\"\r\n        Substitutes all special numeric strings in expression.\r\n        :param expression: any algebraic expression\r\n        :param reverse: flag for reverse substitution\r\n        :return: expression with substituted special numeric strings\r\n        \"\"\"\r\n        substitutions: dict = self._special_numeric_strings_substitutions\r\n        replaced_string: str = expression\r\n        if reverse:\r\n            for special_string in substitutions:\r\n                wrapped_subs_string: str = f\"{Ad.LEFT_BRACKET}{substitutions[special_string]}{Ad.RIGHT_BRACKET}\"\r\n                replaced_string = replaced_string.replace(wrapped_subs_string, special_string)\r\n            self._substitution_index = 1\r\n            return replaced_string\r\n        for special_string in Ad.SPECIAL_NUMERIC_STRINGS:\r\n            replaced_string = self.__substitute_special_numeric_string(replaced_string, special_string)\r\n        return replaced_string\r\n\r\n    def __magic_operation_method_result(self, other, operator: str):\r\n        left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET\r\n        exp_other = AlgExp.initializer(other)\r\n        add_result: str = f\"{left_br}{self}{right_br}{operator}{left_br}{exp_other}{right_br}\"\r\n        return AlgExp.initializer(add_result)\r\n\r\n    def __magic_operation_method_r_result(self, other, magic_operation_method):\r\n        exp1 = AlgExp.initializer(other)\r\n        return magic_operation_method(exp1, self)\r\n\r\n    def __substitute_special_numeric_string(self, expression: str, special_string: str) -> str:\r\n        \"\"\"\r\n        Substitutes special numeric string in expression based on allowed patterns in this method.\r\n        After that, returns this substituted expression.\r\n        :param expression: any algebraic expression\r\n        :param special_string: any special string from special numeric strings\r\n        :return: expression with substituted special numeric string\r\n        \"\"\"\r\n        left_br, right_br, i = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET, Ad.IMAG_UNIT\r\n        subs_chr, subs_index = Ad.SUBSTITUTION_CHARACTER, self._substitution_index\r\n        var_chars, var_chars_without_i = Patterns.ALLOWED_VAR_CHARS, Patterns.ALLOWED_VAR_CHARS_WITHOUT_IMAG_UNIT\r\n        replaced_string: str = expression\r\n        subs_string: str = f\"{subs_chr}{subs_index}\"\r\n        allowed_patterns: tuple = (\r\n            rf\"^({special_string})[^{var_chars}]\",\r\n            rf\"[^{var_chars}]({special_string})[^{var_chars}]\",\r\n            rf\"[^{var_chars}]({special_string})$\",\r\n            rf\"^({special_string}){i}\",\r\n            rf\"{i}({special_string})$\",\r\n            rf\"{i}({special_string}){i}\",\r\n            rf\"{i}({special_string})[^{var_chars}]\",\r\n            rf\"[^{var_chars}]({special_string}){i}\",\r\n        )\r\n        pattern_for_special_string = re.compile(\"|\".join(allowed_patterns))\r\n        founds = re.search(pattern_for_special_string, expression)\r\n        if founds is None:\r\n            return expression\r\n        for founds_index in range(1, len(allowed_patterns) + 1):\r\n            if founds.group(founds_index):\r\n                replaced_string = str(\r\n                    re.subn(founds.group(founds_index), f\"{left_br}{subs_string}{right_br}\", replaced_string)[0])\r\n        self._special_numeric_strings_substitutions[special_string] = subs_string\r\n        self._substitution_index += 1\r\n        return replaced_string\r\n\r\n    @staticmethod\r\n    def initializer(expression: Any = 0, classes_for_init: tuple = None):\r\n        \"\"\"\r\n        Returns an instance of AlgExp based on classes for initialization.\r\n        :param expression: any algebraic expression\r\n        :param classes_for_init: classes given to create an instance of AlgExp\r\n        :return: instance of AlgExp\r\n        \"\"\"\r\n        def __all_subclasses(top_cls, allow_abstract: bool = False) -> tuple:\r\n            \"\"\"\r\n            Returns all subclasses of top class.\r\n            If allow_abstract is set on True, then abstract classes are also returned.\r\n            Otherwise, only concrete classes are returned.\r\n            :param top_cls: class from which its subclasses are searched\r\n            :param allow_abstract: flag for abstract classes [False]\r\n            :return: all subclasses of top class (with/without abstract classes depending on allow_abstract)\r\n            \"\"\"\r\n            from algexptools import NumericAtomicAlgExp, NumericCompositeAlgExp, VariableAtomicAlgExp, \\\r\n                VariableCompositeAlgExp\r\n            actual_cls = top_cls\r\n            all_subclasses: tuple = (actual_cls,)\r\n            for cls in actual_cls.__subclasses__():\r\n                all_subclasses += __all_subclasses(cls)\r\n            if not allow_abstract:\r\n                all_subclasses = tuple(cls for cls in all_subclasses if not isabstract(cls))\r\n            return all_subclasses\r\n\r\n        if classes_for_init is None:\r\n            classes_for_init = __all_subclasses(AlgExp)\r\n        for actual_class in classes_for_init:\r\n            try:\r\n                return actual_class(expression)\r\n            except (AssertionError, ValueError):\r\n                pass\r\n        is_not_composite: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ALG_EXP, expression)\r\n        raise ValueError(f\"{AlgExp._ERR}{is_not_composite}\")\r\n\r\n    @staticmethod\r\n    def _bracketing(expression: str, analyzed_brackets: list = None) -> list:\r\n        \"\"\"\r\n        Returns brackets structure in expression like string.\r\n        Each character is analyzed for its brackets deep level and each such level as a number\r\n        is stored in the bracketing list. Finally, this list is returned.\r\n        e.g. \"a*(b+c)\" => [0, 0, 1, 1, 1, 1, 0]\r\n        e.g. \"2*(1+3)+4*(5-(6+7))\" => [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 1, 0]\r\n        :param expression: any algebraic expression\r\n        :param analyzed_brackets: brackets that are analyzed during bracketing\r\n        :return: list of brackets deep levels for each character in expression string\r\n        \"\"\"\r\n        if analyzed_brackets is None:\r\n            analyzed_brackets = [(Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET)]\r\n        analyzed_left_brackets: Tuple[str] = tuple(brackets_pair[0] for brackets_pair in analyzed_brackets)\r\n        analyzed_right_brackets: Tuple[str] = tuple(brackets_pair[1] for brackets_pair in analyzed_brackets)\r\n        bracketing: list = []\r\n        brackets_level: int = 0\r\n        for character in expression:\r\n            if character in analyzed_left_brackets:\r\n                brackets_level += 1\r\n            elif character in analyzed_right_brackets:\r\n                brackets_level -= 1\r\n            bracketing.append(brackets_level)\r\n        return bracketing\r\n\r\n    @staticmethod\r\n    def _remove_redundant_pluses_minuses(expression: str) -> str:\r\n        \"\"\"\r\n        Removes redundant pluses and minuses based on pattern and replace table in this method.\r\n        Finally, the method removes unnecessary pluses from the beginning of the string\r\n        and all pluses that follow the left bracket.\r\n        :param expression: any algebraic expression\r\n        :return: expression string without redundant pluses and minuses\r\n        \"\"\"\r\n        minus, plus = Ad.MINUS, Ad.PLUS\r\n        left_br: str = Ad.LEFT_BRACKET\r\n        pattern_redundant_pluses_minuses = re.compile(\"[\" + minus + plus + \"]{2}\")\r\n        replace_table: dict = {f\"{minus}{minus}\": plus, f\"{minus}{plus}\": minus, f\"{plus}{minus}\": minus,\r\n                               f\"{plus}{plus}\": plus}\r\n        while re.findall(pattern_redundant_pluses_minuses, expression):\r\n            for redundant_string in replace_table:\r\n                expression = expression.replace(redundant_string, replace_table[redundant_string])\r\n        if expression.startswith(plus):\r\n            expression = expression[1:]\r\n        expression = expression.replace(left_br + plus, left_br)\r\n        return expression\r\n\r\n    @staticmethod\r\n    def _remove_white_spaces(expression: str) -> str:\r\n        \"\"\"\r\n        Removes all white spaces from expression string and after that this replaced string is returned.\r\n        :param expression: any algebraic expression\r\n        :return: expression string without any white spaces\r\n        \"\"\"\r\n        pattern_white_spaces = re.compile(Patterns.WHITE_SPACES)\r\n        return re.sub(pattern_white_spaces, \"\", expression)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algexptools/algexp.py b/algexptools/algexp.py
--- a/algexptools/algexp.py	(revision e0ae38b29b3dbfb62d4685580ce6bac30e683b6c)
+++ b/algexptools/algexp.py	(date 1700328286311)
@@ -142,7 +142,8 @@
         :param expression: any algebraic expression
         :return: None
         """
-        must_be_instance: str = ErrorMessages.replace(ErrorMessages.EXP_MUST_BE_INSTANCE, self.__class__)
+        must_be_instance: str = ErrorMessages.replace(ErrorMessages.MUST_BE_INSTANCE, "Expression",
+                                                      self.__class__.__name__)
         assert isinstance(expression, self.__class__), f"{self._ERR}{must_be_instance}"
         self._content = expression.content
 
@@ -291,8 +292,8 @@
                 return actual_class(expression)
             except (AssertionError, ValueError):
                 pass
-        is_not_composite: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ALG_EXP, expression)
-        raise ValueError(f"{AlgExp._ERR}{is_not_composite}")
+        is_not_alg_exp: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, AlgExp.__name__)
+        raise ValueError(f"{AlgExp._ERR}{is_not_alg_exp}")
 
     @staticmethod
     def _bracketing(expression: str, analyzed_brackets: list = None) -> list:
Index: algsettools/discretealgset.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from copy import deepcopy\r\nfrom inpt import Inpt\r\nfrom typing import Any, List\r\n\r\nfrom algebradata import AlgebraData as Ad\r\nfrom algexptools import NumericAlgExp\r\nfrom algsettools import AlgSet\r\nfrom errormessages import ErrorMessages\r\n\r\n\r\nclass DiscreteAlgSet(AlgSet):\r\n    \"\"\"\r\n    Contains one discrete set that contains a finite number of any NumericAlgExp instances.\\n\r\n    A call with no parameters creates an empty set.\\n\r\n    \"\"\"\r\n    _PREFIX: str = \"DiscreteAlgSet\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # common variables\r\n    _content: list = None\r\n\r\n    def __init__(self, *args):\r\n        discrete_set: tuple = deepcopy(args)\r\n        if not discrete_set:\r\n            discrete_set = ()\r\n        if len(args) == 1 and isinstance(args[0], self.__class__):\r\n            super().__init__(args[0])\r\n        else:\r\n            super().__init__(discrete_set)\r\n\r\n    def __bool__(self):\r\n        return not self.is_empty()\r\n\r\n    def __contains__(self, item):\r\n        try:\r\n            item = self._filter_number(item)\r\n        except (AssertionError, ValueError):\r\n            return False\r\n        for inner_alg_exp in self:\r\n            if inner_alg_exp == item:\r\n                return True\r\n        return False\r\n\r\n    def __eq__(self, other):\r\n        eq: bool = super().__eq__(other)\r\n        if not eq:\r\n            return False\r\n        if len(self) != len(other):\r\n            return False\r\n        # lengths are equal\r\n        self_exp_values: List[complex] = [inner_alg_exp.value for inner_alg_exp in self._content]\r\n        other_exp_values: List[complex] = [inner_alg_exp.value for inner_alg_exp in other.content]\r\n        while self_exp_values:\r\n            actual_value: complex = self_exp_values[0]\r\n            if actual_value not in other_exp_values:\r\n                return False\r\n            self_exp_values.remove(actual_value)\r\n            other_exp_values.remove(actual_value)\r\n        return True\r\n\r\n    def __iter__(self):\r\n        return iter(self._content)\r\n\r\n    def __len__(self):\r\n        return len(self._content)\r\n\r\n    def __repr__(self):\r\n        return f\"DiscreteSet({self})\"\r\n\r\n    def __str__(self):\r\n        content_str = Ad.LEFT_SET_BRACKET\r\n        for inner_alg_exp in self._content:\r\n            content_str += str(inner_alg_exp) + Ad.SET_SEPARATOR\r\n        if len(content_str) > 1:\r\n            content_str = content_str[:-1]\r\n        content_str += Ad.RIGHT_SET_BRACKET\r\n        return content_str\r\n\r\n    def add(self, number: complex | float | int | NumericAlgExp) -> None:\r\n        \"\"\"\r\n        Adds a number to self-set.\r\n        :param number: any NumericAlgExp instance\r\n        :return: None\r\n        \"\"\"\r\n        if number not in self._content:\r\n            self._content.append(self._filter_number(number))\r\n\r\n    def is_empty(self):\r\n        return self._content == []\r\n\r\n    def remove(self, number: complex | float | int | NumericAlgExp) -> None:\r\n        \"\"\"\r\n        Removes number from self-set if set contains it.\r\n        Otherwise, throws an exception.\r\n        :param number: any NumericAlgExp instance\r\n        :return: None\r\n        \"\"\"\r\n        exp_not_in_set: str = ErrorMessages.replace(ErrorMessages.EXP_NOT_IN_SET, (number, self))\r\n        wanted_number_index: int = self.__first_index_of_number(number)\r\n        if wanted_number_index == -1:\r\n            raise ValueError(f\"{self._ERR}{exp_not_in_set}\")\r\n        del self._content[wanted_number_index]\r\n\r\n    def _correct_content(self, set_content: list) -> list:\r\n        indexes_for_remove: List[int] = []\r\n        actual_index: int = 0\r\n        while actual_index < len(set_content) - 1:\r\n            compare_exp_index: int = actual_index + 1\r\n            while compare_exp_index < len(set_content):\r\n                if set_content[actual_index] == set_content[compare_exp_index]:\r\n                    if compare_exp_index not in indexes_for_remove:\r\n                        indexes_for_remove.append(compare_exp_index)\r\n                compare_exp_index += 1\r\n            actual_index += 1\r\n        # indexes must be sorted and reversed for removing loop. There is a good reason for that.\r\n        # Imagine what would have happened if this had not been used... :^)\r\n        for remove_index in reversed(sorted(indexes_for_remove)):\r\n            del set_content[remove_index]\r\n        return set_content\r\n\r\n    def _create_content(self, alg_set: Any) -> None:\r\n        if isinstance(alg_set, self.__class__):\r\n            self._content = deepcopy(alg_set.content)\r\n            return\r\n        pre_content: list = []\r\n        for number in alg_set:\r\n            pre_content.append(self._filter_number(number))\r\n        self._content = self._correct_content(pre_content)\r\n\r\n    def _init_check(self, alg_set: Any):\r\n        self._allowed_types = (list, set)\r\n        self._asserts = []\r\n        super()._init_check(alg_set)\r\n\r\n    def __first_index_of_number(self, wanted_number: complex | float | int | NumericAlgExp) -> int:\r\n        \"\"\"\r\n        Returns first index of wanted number.\r\n        If wanted number is not found, returns -1.\r\n        :param wanted_number: number for which I want to know the first occurrence index\r\n        :return: see doc\r\n        \"\"\"\r\n        for (i, inner_alg_exp) in enumerate(self):\r\n            if inner_alg_exp == wanted_number:\r\n                return i\r\n        return -1\r\n\r\n\r\nif __name__ == '__main__':\r\n    inpt = Inpt(\": \")\r\n    while True:\r\n        alg_set_input: tuple = inpt.inpt_multi()\r\n        if alg_set_input == ():\r\n            break\r\n        try:\r\n            alg_set_outer: DiscreteAlgSet = DiscreteAlgSet(*alg_set_input)\r\n            print(f\"alg_set: {alg_set_outer}\")\r\n        except Exception as err:\r\n            print(err)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algsettools/discretealgset.py b/algsettools/discretealgset.py
--- a/algsettools/discretealgset.py	(revision e0ae38b29b3dbfb62d4685580ce6bac30e683b6c)
+++ b/algsettools/discretealgset.py	(date 1700328352164)
@@ -95,7 +95,7 @@
         :param number: any NumericAlgExp instance
         :return: None
         """
-        exp_not_in_set: str = ErrorMessages.replace(ErrorMessages.EXP_NOT_IN_SET, (number, self))
+        exp_not_in_set: str = ErrorMessages.replace(ErrorMessages.EXP_NOT_IN_SET, number, self)
         wanted_number_index: int = self.__first_index_of_number(number)
         if wanted_number_index == -1:
             raise ValueError(f"{self._ERR}{exp_not_in_set}")
Index: algexptools/compositealgexp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC\r\nfrom typing import List, Tuple\r\nimport re\r\n\r\nfrom algebradata import AlgebraData as Ad\r\nfrom algexptools import AlgExp\r\nfrom errormessages import ErrorMessages\r\nfrom patterns import Patterns\r\n\r\n\r\nclass CompositeAlgExp(AlgExp, ABC):\r\n    \"\"\"\r\n    Abstract class for composite algebraic expressions <=> expressions with at least one operation.\r\n    - NumericCompositeAlgExp   complex number with operations\r\n    - VariableCompositeAlgExp  variables with operations\r\n    \"\"\"\r\n    _PREFIX: str = \"CompositeAlgExp\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # common variables\r\n    _content: list = None\r\n    _operator: str = None\r\n    _simplified: bool = False\r\n\r\n    def __contains__(self, item):\r\n        super().__contains__(item)\r\n        string_item: str = str(item)\r\n        for inner_exp in self._content:\r\n            if string_item in inner_exp:\r\n                return True\r\n        return False\r\n\r\n    def __str__(self):\r\n        left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET\r\n        operators: tuple = Ad.OPERATORS\r\n        composite_string_content: str = \"\"\r\n        for inner_alg_exp in self._content:\r\n            if not isinstance(inner_alg_exp, CompositeAlgExp) and isinstance(inner_alg_exp, AlgExp):\r\n                if inner_alg_exp.content.startswith(Ad.MINUS):\r\n                    composite_string_content += f\"{left_br}{inner_alg_exp}{right_br}{self._operator}\"\r\n                else:\r\n                    composite_string_content += f\"{inner_alg_exp}{self._operator}\"\r\n            # inner_alg_exp is composite\r\n            elif operators.index(self._operator) > operators.index(inner_alg_exp.operator):\r\n                composite_string_content += f\"{left_br}{inner_alg_exp}{right_br}{self._operator}\"\r\n            elif self._operator == inner_alg_exp.operator == Ad.DIV:\r\n                composite_string_content += f\"{left_br}{inner_alg_exp}{right_br}{self._operator}\"\r\n            else:  # self._operator has lower priority than inner_alg_exp.operator\r\n                composite_string_content += f\"{inner_alg_exp}{self._operator}\"\r\n        return composite_string_content[:-1]\r\n\r\n    @property\r\n    def operator(self):\r\n        return self._operator\r\n\r\n    @property\r\n    def simplified(self):\r\n        return self._simplified\r\n\r\n    def has_imag(self) -> bool:\r\n        for inner_alg_exp in self._content:\r\n            if inner_alg_exp.has_imag():\r\n                return True\r\n        return False\r\n\r\n    def _alg_exp_structure(self, expression: str, is_variable_exp: bool) -> list:\r\n        \"\"\"\r\n        Creates specific structure (named as content) for self instance from actual\r\n        expression string.\r\n        If content is to be created for a variable type, flag is_variable_exp is set\r\n        to True. Otherwise, it is set to False.\r\n        :param expression: any algebraic expression\r\n        :param is_variable_exp: flag for structure for variable expression\r\n        :return: specific structure named as content for actual expression string\r\n        \"\"\"\r\n        from algexptools import VariableAlgExp\r\n        left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET\r\n        left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET\r\n        analyzed_brackets: List[Tuple[str, str]] = [(left_br, right_br), (left_imm_br, right_imm_br)]\r\n        is_not_composite: str = ErrorMessages.replace(ErrorMessages.IS_NOT_COMPOSITE, expression)\r\n        indexes_of_operators: dict = {operator: [] for operator in Ad.OPERATORS}\r\n        expression_parts: list = []\r\n        operator_for_split: str = \"\"\r\n        contains_variable: bool = False\r\n        bracketing: list = self._bracketing(expression, analyzed_brackets)\r\n        for i, deep_level in enumerate(bracketing):\r\n            if deep_level == 0 and expression[i] in Ad.OPERATORS:\r\n                actual_operator: str = expression[i]\r\n                indexes_of_operators[actual_operator].append(i)\r\n        for operator in Ad.OPERATORS:\r\n            if indexes_of_operators[operator]:\r\n                operator_for_split = operator\r\n                start_index: int = 0\r\n                for actual_index in indexes_of_operators[operator_for_split]:\r\n                    inner_alg_exp = AlgExp.initializer(expression[start_index:actual_index])\r\n                    if not contains_variable and isinstance(inner_alg_exp, VariableAlgExp):\r\n                        contains_variable = True\r\n                    expression_parts.append(inner_alg_exp)\r\n                    start_index = actual_index + 1\r\n                last_inner_alg_exp = AlgExp.initializer(expression[start_index:])\r\n                if not contains_variable and isinstance(last_inner_alg_exp, VariableAlgExp):\r\n                    contains_variable = True\r\n                expression_parts.append(last_inner_alg_exp)\r\n                break\r\n        if operator_for_split == \"\":\r\n            raise ValueError(f\"{self._ERR}{is_not_composite}\")\r\n        if not contains_variable and is_variable_exp:\r\n            raise ValueError(f\"{self._ERR}{ErrorMessages.MUST_CONTAIN_VARIABLE}\")\r\n        self._operator = operator_for_split\r\n        return expression_parts\r\n\r\n    def _create_content_from_other_instance(self, expression):\r\n        super()._create_content_from_other_instance(expression)\r\n        self._operator = expression.operator\r\n\r\n    def _check_content(self) -> None:\r\n        \"\"\"\r\n        Searches in expression all inner expressions and checks in each of them\r\n        whether it is divisible by zero. If so, it throws an exception.\r\n        :return: None\r\n        \"\"\"\r\n        for inner_alg_exp in self._content[1:]:\r\n            if self._operator == Ad.DIV and inner_alg_exp.content == \"0\":\r\n                raise ZeroDivisionError(f\"{self._ERR}: {ErrorMessages.CANNOT_DIV_BY_ZERO}\")\r\n            if isinstance(inner_alg_exp, CompositeAlgExp):\r\n                inner_alg_exp._check_content()\r\n\r\n    def _replace_minuses(self, expression: str) -> str:\r\n        \"\"\"\r\n        Using the method to find replaceable minuses, it replaces these minuses\r\n        with the string \"+(-1)*\".\r\n        :param expression: any algebraic expression\r\n        :return: expression string with some minuses replaced\r\n        \"\"\"\r\n        minus, plus = Ad.MINUS, Ad.PLUS\r\n        left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET\r\n        multiply = Ad.MULTIPLY\r\n        replace_string: str = f\"{plus}{left_br}{minus}1{right_br}{multiply}\"  # == \"+(-1)*\"\r\n        for index_allowed in reversed(self.__indexes_of_minuses_for_replace(expression)):\r\n            expression = expression[:index_allowed] + replace_string + expression[index_allowed + 1:]\r\n        if expression.startswith(plus):\r\n            expression = expression[1:]\r\n        expression = expression.replace(left_br + plus, left_br)\r\n        return expression\r\n\r\n    def __indexes_of_minuses_for_replace(self, expression: str) -> list:\r\n        \"\"\"\r\n        Returns a list of indexes intended for substitution for another string.\r\n        :param expression: any algebraic expression\r\n        :return: see doc\r\n        \"\"\"\r\n        minus: str = Ad.MINUS\r\n        left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET\r\n        left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET\r\n        indexes_allowed: list = []\r\n        indexes_restricted: list = []\r\n        minus_one_in_brackets: str = rf\"\\{left_br}{minus}1\\{right_br}\"\r\n        pattern_minus_one_in_brackets = re.compile(minus_one_in_brackets)\r\n        if minus not in expression:\r\n            return []\r\n        if self._is_wrapped_in_brackets(expression, left_imm_br, right_imm_br):\r\n            return []\r\n        if expression == f\"{minus}1\":\r\n            return []\r\n        for found in re.finditer(pattern_minus_one_in_brackets, expression):\r\n            indexes_restricted.append(found.start() + minus_one_in_brackets.index(minus) - 1)\r\n        for i, character in enumerate(expression):\r\n            if character == minus and i not in indexes_restricted:\r\n                indexes_allowed.append(i)\r\n        return indexes_allowed\r\n\r\n    @staticmethod\r\n    def _add_multiply_operators(expression: str) -> str:\r\n        \"\"\"\r\n        In places determined by combinations of characters, it inserts *\r\n        between these two characters, in all their occurrences.\r\n        :param expression: any algebraic expression\r\n        :return: expression string with the character \"*\" completed in the given places\r\n        \"\"\"\r\n        variable: str = rf\"[{Patterns.ALLOWED_VAR_CHARS}]\"\r\n        digit: str = r\"\\d\"\r\n        left_br: str = \"\\\\\" + Ad.LEFT_BRACKET\r\n        right_br: str = \"\\\\\" + Ad.RIGHT_BRACKET\r\n        left_imm_br: str = \"\\\\\" + Ad.LEFT_IMMUTABLE_BRACKET\r\n        right_imm_br: str = \"\\\\\" + Ad.RIGHT_IMMUTABLE_BRACKET\r\n        combinations_for_multiply = (\r\n            digit + variable,  # 2x\r\n            digit + left_br,  # 2(\r\n            digit + left_imm_br,  # 2{\r\n            variable + digit,  # x2\r\n            variable + variable,  # xx\r\n            variable + left_br,  # x(\r\n            variable + left_imm_br,  # x{\r\n            right_br + digit,  # )2\r\n            right_br + variable,  # )x\r\n            right_br + left_br,  # )(\r\n            right_br + left_imm_br,  # ){\r\n            right_imm_br + digit,  # }2\r\n            right_imm_br + variable,  # }x\r\n            right_imm_br + left_br,  # }(\r\n            right_imm_br + left_imm_br,  # }{\r\n        )\r\n        pattern_combinations_for_multiply = re.compile(\"|\".join(combinations_for_multiply))\r\n        while re.findall(pattern_combinations_for_multiply, expression):\r\n            for found_string in re.findall(pattern_combinations_for_multiply, expression):\r\n                expression = expression.replace(found_string, found_string[0] + Ad.MULTIPLY + found_string[1])\r\n        return expression\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algexptools/compositealgexp.py b/algexptools/compositealgexp.py
--- a/algexptools/compositealgexp.py	(revision e0ae38b29b3dbfb62d4685580ce6bac30e683b6c)
+++ b/algexptools/compositealgexp.py	(date 1700328306793)
@@ -77,7 +77,7 @@
         left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET
         left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET
         analyzed_brackets: List[Tuple[str, str]] = [(left_br, right_br), (left_imm_br, right_imm_br)]
-        is_not_composite: str = ErrorMessages.replace(ErrorMessages.IS_NOT_COMPOSITE, expression)
+        is_not_composite: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, CompositeAlgExp.__name__)
         indexes_of_operators: dict = {operator: [] for operator in Ad.OPERATORS}
         expression_parts: list = []
         operator_for_split: str = ""
Index: algsettools/algset.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC, abstractmethod\r\nfrom copy import deepcopy\r\nfrom typing import Any, List\r\n\r\nfrom algexptools import AlgExp, NumericAlgExp, NumericAtomicAlgExp, NumericCompositeAlgExp\r\nfrom errormessages import ErrorMessages\r\n\r\n\r\nclass AlgSet(ABC):\r\n    \"\"\"\r\n    Abstract class for all kinds of sets:\r\n\r\n    - DiscreteAlgSet    set with finitely many numbers\r\n    - IntervalAlgSet    set of all numbers between two limits (infinitely many numbers)\r\n    - UnionAlgSet       combination of Discrete and Interval (must contain at least two subsets)\r\n    \"\"\"\r\n    _PREFIX: str = \"AlgSet\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # common variables\r\n    _content: list | tuple = None\r\n\r\n    # other variables\r\n    _allowed_types: tuple = None\r\n    _asserts: list = None\r\n\r\n    def __init__(self, alg_set: Any):\r\n        self._init_check(alg_set)\r\n        self._create_content(alg_set)\r\n\r\n    @abstractmethod\r\n    def __contains__(self, item):\r\n        return NotImplemented\r\n\r\n    @abstractmethod\r\n    def __repr__(self):\r\n        return NotImplemented\r\n\r\n    @abstractmethod\r\n    def __str__(self):\r\n        return NotImplemented\r\n\r\n    @abstractmethod\r\n    def _correct_content(self, set_content: list | tuple):\r\n        \"\"\"\r\n        Checks and, if necessary, simplifies set_content.\r\n        :param set_content: content of the given set\r\n        :return: reviewed and possibly modified set_content\r\n        \"\"\"\r\n        return NotImplemented\r\n\r\n    @abstractmethod\r\n    def _create_content(self, alg_set: Any):\r\n        \"\"\"\r\n        Creates content of the given alg_set.\r\n        :param alg_set: given set\r\n        :return: None\r\n        \"\"\"\r\n        return NotImplemented\r\n\r\n    def __eq__(self, other) -> bool:\r\n        return isinstance(other, self.__class__)\r\n\r\n    def __ne__(self, other):\r\n        return not self.__eq__(other)\r\n\r\n    @property\r\n    def content(self):\r\n        return self._content\r\n\r\n    def _filter_number(self, number: Any) -> NumericAlgExp:\r\n        \"\"\"\r\n        Checks if given number is suitable for insertion into self-set.\r\n        :param number: any number suitable for self-set\r\n        :return: instance of NumericAlgExp created from number\r\n        \"\"\"\r\n        if isinstance(number, NumericAlgExp):\r\n            return number\r\n        return AlgExp.initializer(number, (NumericAtomicAlgExp, NumericCompositeAlgExp))\r\n\r\n    def _init_check(self, alg_set: Any) -> None:\r\n        \"\"\"\r\n        Sniper filter for throwing an exception if the parameters are invalid.\r\n        :param alg_set: given set\r\n        :return: None\r\n        \"\"\"\r\n        self._allowed_types += (self.__class__, tuple)\r\n        types_string: str = \"(\" + \", \".join([x.__name__ for x in self._allowed_types]) + \")\"\r\n        new_asserts: list = [\r\n            (isinstance(alg_set, self._allowed_types),\r\n             f\"set must be in {types_string}\"),\r\n        ]\r\n        self._asserts += new_asserts\r\n        for condition, err_message in self._asserts:\r\n            assert condition, f\"{self._ERR}{err_message}\"\r\n\r\n    @staticmethod\r\n    def intersect(*args):\r\n        \"\"\"\r\n        Returns the intersection of any number of sets.\r\n        :param args: any instances of AlgSet\r\n        :return: intersection of all args\r\n        \"\"\"\r\n        assert len(args) >= 2, f\"{AlgSet._ERR}{ErrorMessages.AT_LEAST_TWO_SETS_FOR_INTERSECTION}\"\r\n        result_set = AlgSet.__intersect(args[0], args[1])\r\n        for actual_set in args[2:]:\r\n            result_set = AlgSet.__intersect(result_set, actual_set)\r\n        return result_set\r\n\r\n    @staticmethod\r\n    def union(*args):\r\n        \"\"\"\r\n        Returns the union of any number of sets.\r\n        :param args: any instances of AlgSet\r\n        :return: union of all args\r\n        \"\"\"\r\n        assert len(args) >= 2, f\"{AlgSet._ERR}{ErrorMessages.AT_LEAST_TWO_SETS_FOR_UNION}\"\r\n        result_set = AlgSet.__union(args[0], args[1])\r\n        if len(args) > 2:\r\n            for actual_set in args[2:]:\r\n                result_set = AlgSet.__union(result_set, actual_set)\r\n        return result_set\r\n\r\n    @staticmethod\r\n    def _union_of_intersectioned_intervals(interval1, interval2):\r\n        \"\"\"\r\n        Returns union of two intervals with non-empty intersection.\r\n        :param interval1: interval set\r\n        :param interval2: interval set\r\n        :return: see doc\r\n        \"\"\"\r\n        from algsettools import Intersections, IntervalAlgSet\r\n        l1, u1 = interval1.lower_limit.value.real, interval1.upper_limit.value.real\r\n        l2, u2 = interval2.lower_limit.value.real, interval2.upper_limit.value.real\r\n        l1_closed, u1_closed = interval1.is_left_closed(), interval1.is_right_closed()\r\n        l2_closed, u2_closed = interval2.is_left_closed(), interval2.is_right_closed()\r\n        l1_or_l2_closed: bool = l1_closed or l2_closed\r\n        u1_or_u2_closed: bool = u1_closed or u2_closed\r\n        intersection_type: Intersections = AlgSet._intersection_type(interval1, interval2)\r\n        match intersection_type:\r\n            case Intersections.ONE_NUMBER:\r\n                if u1 == l2:  # (l1, u2)\r\n                    return IntervalAlgSet(l1, u2, l1_closed, u2_closed)\r\n                if u2 == l1:  # (l2, u1)\r\n                    return IntervalAlgSet(l2, u1, l2_closed, u1_closed)\r\n            case Intersections.PARTIAL_OVERLAP:\r\n                if l1 < l2 < u1 < u2:  # (l1, u2)\r\n                    return IntervalAlgSet(l1, u2, l1_closed, u2_closed)\r\n                if l2 < l1 < u2 < u1:  # (l2, u1)\r\n                    return IntervalAlgSet(l2, u1, l2_closed, u1_closed)\r\n            case Intersections.INNER_LEFT_OVERLAP_WITHOUT_LOWER:\r\n                if u1 < u2:  # (l1, u2)\r\n                    return IntervalAlgSet(l1, u2, l1_or_l2_closed, u2_closed)\r\n                if u2 < u1:  # (l1, u1)\r\n                    return IntervalAlgSet(l1, u1, l1_or_l2_closed, u1_closed)\r\n            case Intersections.INNER_LEFT_OVERLAP:\r\n                if u1 < u2:  # [l1, u2)\r\n                    return IntervalAlgSet(l1, u2, True, u2_closed)\r\n                if u2 < u1:  # [l1, u1)\r\n                    return IntervalAlgSet(l1, u1, True, u1_closed)\r\n            case Intersections.INNER_OVERLAP:\r\n                if l1 < l2 and u1 > u2:  # (l1, u1)\r\n                    return IntervalAlgSet(l1, u1, l1_closed, u1_closed)\r\n                if l2 < l1 and u2 > u1:  # (l2, u2)\r\n                    return IntervalAlgSet(l2, u2, l2_closed, u2_closed)\r\n            case Intersections.EQUALITY_WITHOUT_LIMITS:  # (l1, u1)\r\n                return IntervalAlgSet(l1, u1, l1_or_l2_closed, u1_or_u2_closed)\r\n            case Intersections.EQUALITY_WITHOUT_LOWER:  # (l1, u1]\r\n                return IntervalAlgSet(l1, u1, l1_or_l2_closed, True)\r\n            case Intersections.EQUALITY_WITHOUT_UPPER:  # [l1, u1)\r\n                return IntervalAlgSet(l1, u1, True, u1_or_u2_closed)\r\n            case Intersections.EQUALITY:  # [l1, u1]\r\n                return IntervalAlgSet(l1, u1, True, True)\r\n            case Intersections.INNER_RIGHT_OVERLAP_WITHOUT_UPPER:\r\n                if l1 < l2:  # (l1, u1)\r\n                    return IntervalAlgSet(l1, u1, l1_closed, u1_or_u2_closed)\r\n                if l2 < l1:  # (l2, u1)\r\n                    return IntervalAlgSet(l2, u1, l2_closed, u1_or_u2_closed)\r\n            case Intersections.INNER_RIGHT_OVERLAP:\r\n                if l1 < l2:  # (l1, u1]\r\n                    return IntervalAlgSet(l1, u1, l1_closed, True)\r\n                if l2 < l1:  # (l2, u1]\r\n                    return IntervalAlgSet(l2, u1, l2_closed, True)\r\n            case _:\r\n                intersection_not_recognized: str = ErrorMessages.replace(ErrorMessages.INTERSECTION_NOT_RECOGNIZED,\r\n                                                                         (interval1, interval2))\r\n                raise ValueError(f\"{AlgSet._ERR}{intersection_not_recognized}\")\r\n\r\n    @staticmethod\r\n    def _include_numbers_from_discrete_set_into_intervals(alg_set: list) -> None:\r\n        \"\"\"\r\n        Inserts, if possible, numbers from DiscreteSet into one of the intervals in alg_set.\r\n        These inserted numbers are then removed from discreteSet.\r\n        :param alg_set: list of any sets\r\n        :return: None\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, IntervalAlgSet\r\n        inner_discrete: DiscreteAlgSet = DiscreteAlgSet()\r\n        for inner_set in alg_set:\r\n            if isinstance(inner_set, DiscreteAlgSet):\r\n                inner_discrete = inner_set\r\n                break\r\n        if not inner_discrete:\r\n            return\r\n        remove_indexes: List[int] = []\r\n        for inner_set in alg_set:\r\n            if isinstance(inner_set, IntervalAlgSet):\r\n                for i, number in enumerate(inner_discrete):\r\n                    if number in inner_set or number in (inner_set.lower_limit, inner_set.upper_limit):\r\n                        if number in inner_set:\r\n                            pass\r\n                        elif number == inner_set.lower_limit:\r\n                            inner_set.add_lower_limit()\r\n                        elif number == inner_set.upper_limit:\r\n                            inner_set.add_upper_limit()\r\n                        if i not in remove_indexes:\r\n                            remove_indexes.append(i)\r\n        # indexes must be sorted and reversed for removing loop. There is a good reason for that.\r\n        # Imagine what would have happened if this had not been used... :^)\r\n        for remove_index in reversed(sorted(remove_indexes)):\r\n            del inner_discrete.content[remove_index]\r\n        if not inner_discrete:\r\n            alg_set.remove(inner_discrete)\r\n\r\n    @staticmethod\r\n    def _intersection_type(interval1, interval2):\r\n        \"\"\"\r\n        Returns type of intersection of given intervals.\r\n        :param interval1: intervalSet\r\n        :param interval2: intervalSet\r\n        :return: see doc\r\n        \"\"\"\r\n        from algsettools import Intersections\r\n        l1_closed: bool = True if interval1.is_left_closed() else False\r\n        u1_closed: bool = True if interval1.is_right_closed() else False\r\n        l2_closed: bool = True if interval2.is_left_closed() else False\r\n        u2_closed: bool = True if interval2.is_right_closed() else False\r\n        l1, u1 = interval1.lower_limit.value.real, interval1.upper_limit.value.real\r\n        l2, u2 = interval2.lower_limit.value.real, interval2.upper_limit.value.real\r\n        if u1 < l2 or u2 < l1:\r\n            return Intersections.EMPTY\r\n        if u1 == l2 or u2 == l1:\r\n            if (u1 == l2 and u1_closed and l2_closed) or (u2 == l1 and u2_closed and l1_closed):\r\n                return Intersections.ONE_NUMBER\r\n            return Intersections.EMPTY\r\n        if l1 == u1 or l2 == u2:\r\n            return Intersections.ONE_NUMBER\r\n        if (l1 < l2 and u1 > u2) or (l2 < l1 and u2 > u1):\r\n            return Intersections.INNER_OVERLAP\r\n        if (l1 < l2 < u1 < u2) or (l2 < l1 < u2 < u1):\r\n            return Intersections.PARTIAL_OVERLAP\r\n        if (l1 == l2 and u1 < u2) or (l2 == l1 and u2 < u1):\r\n            if l1_closed and l2_closed:\r\n                return Intersections.INNER_LEFT_OVERLAP\r\n            return Intersections.INNER_LEFT_OVERLAP_WITHOUT_LOWER\r\n        if l1 == l2 and u1 == u2:\r\n            if l1_closed and l2_closed:\r\n                if u1_closed and u2_closed:\r\n                    return Intersections.EQUALITY\r\n                return Intersections.EQUALITY_WITHOUT_UPPER\r\n            if u1_closed and u2_closed:\r\n                return Intersections.EQUALITY_WITHOUT_LOWER\r\n            return Intersections.EQUALITY_WITHOUT_LIMITS\r\n        if (l1 < l2 and u1 == u2) or (l2 < l1 and u2 == u1):\r\n            if u1_closed and u2_closed:\r\n                return Intersections.INNER_RIGHT_OVERLAP\r\n            return Intersections.INNER_RIGHT_OVERLAP_WITHOUT_UPPER\r\n        return Intersections.UNKNOWN_INTERSECTION\r\n\r\n    @staticmethod\r\n    def _single_digit_intervals_to_discrete_sets(alg_set: list) -> None:\r\n        \"\"\"\r\n        Converts intervals [x, x] to a number x, which it stores in discreteSet.\r\n        :param alg_set: list of any sets\r\n        :return: None\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, IntervalAlgSet\r\n        remove_indexes: List[int] = []\r\n        numbers: list = []\r\n        for i, inner_set in enumerate(alg_set):\r\n            if isinstance(inner_set, IntervalAlgSet) and inner_set.is_one_number():\r\n                numbers.append(inner_set.lower_limit)\r\n                remove_indexes.append(i)\r\n        for remove_index in reversed(remove_indexes):\r\n            del alg_set[remove_index]\r\n        if remove_indexes:\r\n            alg_set.insert(0, DiscreteAlgSet(*numbers))\r\n\r\n    @staticmethod\r\n    def _union_discrete_sets(discrete1, discrete2):\r\n        \"\"\"\r\n        Returns the union of two discreteSets.\r\n        :param discrete1: discreteSet\r\n        :param discrete2: discreteSet\r\n        :return: union of two given discreteSets\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet\r\n        smaller_discrete, greater_discrete = sorted((discrete1, discrete2), key=len)\r\n        union_discrete: DiscreteAlgSet = deepcopy(greater_discrete)\r\n        for inner_alg_exp in smaller_discrete:\r\n            union_discrete.add(inner_alg_exp)\r\n        return union_discrete\r\n\r\n    @staticmethod\r\n    def __get_set_based_on_intersection_size(intersection_result):\r\n        \"\"\"\r\n        Returns a set based on the type of intersection result.\r\n        :param intersection_result: result of intersection of any sets\r\n        :return: see doc\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, IntervalAlgSet, UnionAlgSet\r\n        if len(intersection_result) == 1:\r\n            if isinstance(intersection_result[0], DiscreteAlgSet):\r\n                return DiscreteAlgSet(*intersection_result)\r\n            return IntervalAlgSet(*intersection_result)\r\n        return UnionAlgSet(*intersection_result)\r\n\r\n    @staticmethod\r\n    def __intersect(alg_set1, alg_set2):\r\n        \"\"\"\r\n        Returns the intersection of two sets based on more specific methods, where the method\r\n        to calculate the intersection is determined by the types of our two sets.\r\n        :param alg_set1: given set\r\n        :param alg_set2: given set\r\n        :return: intersection of two given sets\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, IntervalAlgSet, UnionAlgSet\r\n        methods_for_type_combinations: dict = {  # all different pairs of types\r\n            (DiscreteAlgSet, DiscreteAlgSet): AlgSet.__intersect_discrete_sets,\r\n            (DiscreteAlgSet, IntervalAlgSet): AlgSet.__intersect_discrete_interval,\r\n            (DiscreteAlgSet, UnionAlgSet): AlgSet.__intersect_discrete_union,\r\n            (IntervalAlgSet, IntervalAlgSet): AlgSet.__intersect_intervals,\r\n            (IntervalAlgSet, UnionAlgSet): AlgSet.__intersect_interval_union,\r\n            (UnionAlgSet, UnionAlgSet): AlgSet.__intersect_unions,\r\n        }\r\n        if (alg_set1.__class__, alg_set2.__class__) in methods_for_type_combinations:\r\n            return methods_for_type_combinations[(alg_set1.__class__, alg_set2.__class__)](alg_set1, alg_set2)\r\n        return methods_for_type_combinations[(alg_set2.__class__, alg_set1.__class__)](alg_set2, alg_set1)\r\n\r\n    @staticmethod\r\n    def __intersect_discrete_sets(discrete1, discrete2):\r\n        \"\"\"\r\n        Returns the intersection of two discreteSets.\r\n        :param discrete1: discreteSet\r\n        :param discrete2: discreteSet\r\n        :return: intersection of two given discreteSets\r\n        \"\"\"\r\n        smaller_discrete, greater_discrete = sorted((discrete1, discrete2), key=len)\r\n        new_smaller = deepcopy(smaller_discrete)\r\n        exps_for_remove: list = []\r\n        for inner_alg_exp in new_smaller:\r\n            if inner_alg_exp not in greater_discrete:\r\n                exps_for_remove.append(inner_alg_exp)\r\n        for exp_for_remove in exps_for_remove:\r\n            new_smaller.remove(exp_for_remove)\r\n        return new_smaller\r\n\r\n    @staticmethod\r\n    def __intersect_discrete_interval(alg_set1, alg_set2):\r\n        \"\"\"\r\n        Returns the intersection of discreteSet and interval.\r\n        :param alg_set1: discreteSet or interval\r\n        :param alg_set2: interval or discreteSet\r\n        :return: intersection of given sets: discreteSet and interval\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet\r\n        new_discrete, interval_set = AlgSet.__pair_sets(alg_set1, alg_set2, DiscreteAlgSet)\r\n        new_discrete = deepcopy(new_discrete)\r\n        exps_for_remove: list = []\r\n        for inner_alg_exp in new_discrete:\r\n            if inner_alg_exp not in interval_set:\r\n                exps_for_remove.append(inner_alg_exp)\r\n        for exp_for_remove in exps_for_remove:\r\n            new_discrete.remove(exp_for_remove)\r\n        return new_discrete\r\n\r\n    @staticmethod\r\n    def __intersect_discrete_union(alg_set1, alg_set2):\r\n        \"\"\"\r\n        Returns the intersection of discreteSet and unionSet.\r\n        :param alg_set1: discreteSet or unionSet\r\n        :param alg_set2: unionSet or discreteSet\r\n        :return: intersection of given sets: discreteSet and unionSet\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet\r\n        discrete_set, union_set = AlgSet.__pair_sets(alg_set1, alg_set2, DiscreteAlgSet)\r\n        intersection_result: DiscreteAlgSet = DiscreteAlgSet()\r\n        if union_set.discrete_set:\r\n            intersection_result = AlgSet.__intersect_discrete_sets(discrete_set, *union_set.discrete_set)\r\n        for interval in union_set.intervals:\r\n            new_intersection = AlgSet.__intersect_discrete_interval(discrete_set, interval)\r\n            intersection_result = AlgSet._union_discrete_sets(intersection_result, new_intersection)\r\n        return intersection_result\r\n\r\n    @staticmethod\r\n    def __intersect_intervals(interval1, interval2):\r\n        \"\"\"\r\n        Returns the intersection of two intervals.\r\n        :param interval1: intervalSet\r\n        :param interval2: intervalSet\r\n        :return: intersection of two intervals\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, Intersections, IntervalAlgSet\r\n        l1, u1 = interval1.lower_limit.value.real, interval1.upper_limit.value.real\r\n        l2, u2 = interval2.lower_limit.value.real, interval2.upper_limit.value.real\r\n        l1_closed, u1_closed = interval1.is_left_closed(), interval1.is_right_closed()\r\n        l2_closed, u2_closed = interval2.is_left_closed(), interval2.is_right_closed()\r\n        intersection_type: Intersections = AlgSet._intersection_type(interval1, interval2)\r\n        match intersection_type:\r\n            case Intersections.EMPTY:  # {}\r\n                return DiscreteAlgSet()\r\n            case Intersections.ONE_NUMBER:\r\n                if interval1.is_one_number():  # {l1}\r\n                    return DiscreteAlgSet(l1)\r\n                if interval2.is_one_number():  # {l2}\r\n                    return DiscreteAlgSet(l2)\r\n                if u1 == l2:  # {u1}\r\n                    return DiscreteAlgSet(u1)\r\n                if u2 == l1:  # {l1}\r\n                    return DiscreteAlgSet(l1)\r\n            case Intersections.PARTIAL_OVERLAP:\r\n                if l1 < l2 < u1 < u2:  # (l2, u1)\r\n                    return IntervalAlgSet(l2, u1, l2_closed, u1_closed)\r\n                if l2 < l1 < u2 < u1:  # (l1, u2)\r\n                    return IntervalAlgSet(l1, u2, l1_closed, u2_closed)\r\n            case Intersections.INNER_LEFT_OVERLAP_WITHOUT_LOWER:\r\n                if u1 < u2:  # (l1, u1)\r\n                    return IntervalAlgSet(l1, u1, False, u1_closed)\r\n                if u2 < u1:  # (l1, u2)\r\n                    return IntervalAlgSet(l1, u2, False, u2_closed)\r\n            case Intersections.INNER_LEFT_OVERLAP:\r\n                if u1 < u2:  # (l1, u1)\r\n                    return IntervalAlgSet(l1, u1, True, u1_closed)\r\n                if u2 < u1:  # (l1, u2)\r\n                    return IntervalAlgSet(l1, u2, True, u2_closed)\r\n            case Intersections.INNER_OVERLAP:\r\n                if l1 < l2 and u1 > u2:  # (l2, u2)\r\n                    return IntervalAlgSet(l2, u2, l2_closed, u2_closed)\r\n                if l2 < l1 and u2 > u1:  # (l1, u1)\r\n                    return IntervalAlgSet(l1, u1, l1_closed, u1_closed)\r\n            case Intersections.EQUALITY_WITHOUT_LIMITS:  # (l1, u1)\r\n                return IntervalAlgSet(l1, u1, False, False)\r\n            case Intersections.EQUALITY_WITHOUT_LOWER:  # (l1, u1)\r\n                return IntervalAlgSet(l1, u1, False, True)\r\n            case Intersections.EQUALITY_WITHOUT_UPPER:\r\n                return IntervalAlgSet(l1, u1, True, False)\r\n            case Intersections.EQUALITY:  # (l1, u1)\r\n                return IntervalAlgSet(l1, u1, True, True)\r\n            case Intersections.INNER_RIGHT_OVERLAP_WITHOUT_UPPER:\r\n                if l1 < l2:  # (l2, u1)\r\n                    return IntervalAlgSet(l2, u1, l2_closed, False)\r\n                if l2 < l1:  # (l1, u1)\r\n                    return IntervalAlgSet(l1, u1, l1_closed, False)\r\n            case Intersections.INNER_RIGHT_OVERLAP:\r\n                if l1 < l2:  # (l2, u1)\r\n                    return IntervalAlgSet(l2, u1, l2_closed, True)\r\n                if l2 < l1:  # (l1, u1)\r\n                    return IntervalAlgSet(l1, u1, l1_closed, True)\r\n            case _:\r\n                intersection_not_recognized: str = ErrorMessages.replace(ErrorMessages.INTERSECTION_NOT_RECOGNIZED,\r\n                                                                         (interval1, interval2))\r\n                raise ValueError(f\"{AlgSet._ERR}{intersection_not_recognized}\")\r\n\r\n    @staticmethod\r\n    def __intersect_interval_union(alg_set1, alg_set2):\r\n        \"\"\"\r\n        Returns the intersection of interval and unionSet.\r\n        :param alg_set1: interval or unionSet\r\n        :param alg_set2: unionSet or interval\r\n        :return: intersection of given sets: interval and unionSet\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, Intersections, IntervalAlgSet\r\n        interval_set, union_set = AlgSet.__pair_sets(alg_set1, alg_set2, IntervalAlgSet)\r\n        intersection_result: list = []\r\n        discrete_result: DiscreteAlgSet = DiscreteAlgSet()\r\n        intervals_result: list = []\r\n        if union_set.discrete_set:\r\n            discrete_result = AlgSet.__intersect_discrete_interval(*union_set.discrete_set, interval_set)\r\n        for inner_interval in union_set.intervals:\r\n            if AlgSet._intersection_type(interval_set, inner_interval) != Intersections.EMPTY:\r\n                intervals_intersection = AlgSet.__intersect_intervals(inner_interval, interval_set)\r\n                if isinstance(intervals_intersection, DiscreteAlgSet):\r\n                    discrete_result = AlgSet._union_discrete_sets(discrete_result, intervals_intersection)\r\n                else:\r\n                    intervals_result.append(intervals_intersection)\r\n        if discrete_result:\r\n            intersection_result.append(discrete_result)\r\n        intersection_result += intervals_result\r\n        return AlgSet.__get_set_based_on_intersection_size(intersection_result)\r\n\r\n    @staticmethod\r\n    def __intersect_unions(union_set1, union_set2):\r\n        \"\"\"\r\n        Returns the intersection of two unionSets.\r\n        :param union_set1: unionSet\r\n        :param union_set2: unionSet\r\n        :return: intersection of two unionSets\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, Intersections\r\n        intersection_result: list = []\r\n        discrete_result: DiscreteAlgSet = DiscreteAlgSet()\r\n        intervals_result: list = []\r\n        if union_set1.discrete_set:\r\n            new_discrete = AlgSet.__intersect_discrete_union(*union_set1.discrete_set, union_set2)\r\n            discrete_result = AlgSet._union_discrete_sets(discrete_result, new_discrete)\r\n        if union_set2.discrete_set:\r\n            new_discrete = AlgSet.__intersect_discrete_union(*union_set2.discrete_set, union_set1)\r\n            discrete_result = AlgSet._union_discrete_sets(discrete_result, new_discrete)\r\n        for inner_interval1 in union_set1.intervals:\r\n            for inner_interval2 in union_set2.intervals:\r\n                if AlgSet._intersection_type(inner_interval1, inner_interval2) != Intersections.EMPTY:\r\n                    intervals_intersection = AlgSet.__intersect_intervals(inner_interval1, inner_interval2)\r\n                    if isinstance(intervals_intersection, DiscreteAlgSet):\r\n                        discrete_result = AlgSet._union_discrete_sets(discrete_result, intervals_intersection)\r\n                    else:\r\n                        intervals_result.append(intervals_intersection)\r\n        if discrete_result:\r\n            intersection_result.append(discrete_result)\r\n        intersection_result += intervals_result\r\n        return AlgSet.__get_set_based_on_intersection_size(intersection_result)\r\n\r\n    @staticmethod\r\n    def __min_max_from_intervals(intervals: list, key_function):\r\n        \"\"\"\r\n        Returns the interval with the smallest lower limit / largest upper limit.\r\n        The variants depend on key_function.\r\n        :param intervals: any intervals\r\n        :param key_function: min or max to find wanted limit extreme\r\n        :return: see doc\r\n        \"\"\"\r\n        if key_function == min:\r\n            all_lower_limits: list = [interval.lower_limit.value.real for interval in intervals]\r\n            min_number = min(all_lower_limits)\r\n            for interval in intervals:\r\n                if interval.lower_limit == min_number:\r\n                    return interval\r\n        all_upper_limits: list = [interval.upper_limit.value.real for interval in intervals]\r\n        max_number = max(all_upper_limits)\r\n        for interval in intervals:\r\n            if interval.upper_limit == max_number:\r\n                return interval\r\n\r\n    @staticmethod\r\n    def __pair_sets(alg_set1, alg_set2, first_type):\r\n        \"\"\"\r\n        Returns the correct super trouper combination so that first set in returned tuple\r\n        must be an instance of first_type.\r\n        :param alg_set1: given set\r\n        :param alg_set2: given set\r\n        :param first_type: wanted type for first set in a returned pair of sets\r\n        :return: see doc\r\n        \"\"\"\r\n        if isinstance(alg_set1, first_type):\r\n            return alg_set1, alg_set2\r\n        return alg_set2, alg_set1\r\n\r\n    @staticmethod\r\n    def __union(alg_set1, alg_set2):\r\n        \"\"\"\r\n        Returns the union of two sets based on more specific methods, where the method\r\n        to calculate the union is determined by the types of our two sets.\r\n        :param alg_set1: given set\r\n        :param alg_set2: given set\r\n        :return: union of two given sets\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, IntervalAlgSet, UnionAlgSet\r\n        methods_for_type_combinations: dict = {  # all different pairs of types\r\n            (DiscreteAlgSet, DiscreteAlgSet): AlgSet._union_discrete_sets,\r\n            (DiscreteAlgSet, IntervalAlgSet): AlgSet.__union_discrete_interval,\r\n            (DiscreteAlgSet, UnionAlgSet): AlgSet.__union_discrete_union,\r\n            (IntervalAlgSet, IntervalAlgSet): AlgSet.__union_intervals,\r\n            (IntervalAlgSet, UnionAlgSet): AlgSet.__union_interval_union,\r\n            (UnionAlgSet, UnionAlgSet): AlgSet.__union_unions,\r\n        }\r\n        if (alg_set1.__class__, alg_set2.__class__) in methods_for_type_combinations:\r\n            return methods_for_type_combinations[(alg_set1.__class__, alg_set2.__class__)](alg_set1, alg_set2)\r\n        return methods_for_type_combinations[(alg_set2.__class__, alg_set1.__class__)](alg_set2, alg_set1)\r\n\r\n    @staticmethod\r\n    def __union_discrete_interval(alg_set1, alg_set2):\r\n        \"\"\"\r\n        Returns the union of discreteSet and interval.\r\n        :param alg_set1: discreteSet or interval\r\n        :param alg_set2: interval or discreteSet\r\n        :return: union of given sets: discreteSet and interval\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, IntervalAlgSet, UnionAlgSet\r\n        discrete_set, interval_set = AlgSet.__pair_sets(alg_set1, alg_set2, DiscreteAlgSet)\r\n        set_content: list = [deepcopy(discrete_set), deepcopy(interval_set)]\r\n        AlgSet._single_digit_intervals_to_discrete_sets(set_content)\r\n        if all([isinstance(inner_set, DiscreteAlgSet) for inner_set in set_content]):\r\n            return AlgSet._union_discrete_sets(*set_content)\r\n        AlgSet._include_numbers_from_discrete_set_into_intervals(set_content)\r\n        if len(set_content) == 1:\r\n            return IntervalAlgSet(set_content[0])\r\n        return UnionAlgSet(*set_content)\r\n\r\n    @staticmethod\r\n    def __union_discrete_union(alg_set1, alg_set2):\r\n        \"\"\"\r\n        Returns the union of discreteSet and unionSet.\r\n        :param alg_set1: discreteSet or unionSet\r\n        :param alg_set2: unionSet or discreteSet\r\n        :return: union of given sets: discreteSet and unionSet\r\n        \"\"\"\r\n        from algsettools import DiscreteAlgSet, UnionAlgSet\r\n        discrete_set, union_set = AlgSet.__pair_sets(alg_set1, alg_set2, DiscreteAlgSet)\r\n        discrete_set, union_set = deepcopy(discrete_set), deepcopy(union_set)\r\n        if union_set.discrete_set:\r\n            union_set.discrete_set[0] = AlgSet._union_discrete_sets(union_set.discrete_set[0], discrete_set)\r\n            return union_set\r\n        try:\r\n            return UnionAlgSet(discrete_set, *union_set.intervals)\r\n        except AssertionError:\r\n            # special case - numbers from discrete set may unite disjoint intervals into a single one\r\n            # {1} U (0, 1) U (1, 2) <=> (0, 2) ... And interval (0, 2) is no longer UnionAlgSet\r\n            min_interval = AlgSet.__min_max_from_intervals(union_set.intervals, min)\r\n            max_interval = AlgSet.__min_max_from_intervals(union_set.intervals, max)\r\n            return IntervalAlgSet(min_interval.lower_limit, max_interval.upper_limit, min_interval.is_left_closed(),\r\n                                  max_interval.is_right_closed())\r\n\r\n    @staticmethod\r\n    def __union_intervals(interval1, interval2):\r\n        \"\"\"\r\n        Returns the union of two intervals.\r\n        :param interval1: intervalSet\r\n        :param interval2: intervalSet\r\n        :return: union of two intervals\r\n        \"\"\"\r\n        from algsettools import Intersections, UnionAlgSet\r\n        intersection_type: Intersections = AlgSet._intersection_type(interval1, interval2)\r\n        if intersection_type == Intersections.EMPTY:\r\n            return UnionAlgSet(interval1, interval2)\r\n        return AlgSet._union_of_intersectioned_intervals(interval1, interval2)\r\n\r\n    @staticmethod\r\n    def __union_interval_union(alg_set1, alg_set2):\r\n        \"\"\"\r\n        Returns the union of interval and unionSet.\r\n        :param alg_set1: interval or unionSet\r\n        :param alg_set2: unionSet or interval\r\n        :return: union of given sets: interval and unionSet\r\n        \"\"\"\r\n        from algsettools import IntervalAlgSet, UnionAlgSet\r\n        interval_set, union_set = AlgSet.__pair_sets(alg_set1, alg_set2, IntervalAlgSet)\r\n        return UnionAlgSet(*union_set.content, interval_set)\r\n\r\n    @staticmethod\r\n    def __union_unions(union_set1, union_set2):\r\n        \"\"\"\r\n        Returns the union of two unions.\r\n        :param union_set1: unionSet\r\n        :param union_set2: unionSet\r\n        :return: union of two unionSets\r\n        \"\"\"\r\n        union_set1, union_set2 = deepcopy(union_set1), deepcopy(union_set2)\r\n        return UnionAlgSet(*union_set1.content, *union_set2.discrete_set, *union_set2.intervals)\r\n\r\n\r\nif __name__ == '__main__':\r\n    from algsettools import DiscreteAlgSet, IntervalAlgSet, UnionAlgSet\r\n    s1 = IntervalAlgSet(0, 1)\r\n    s2 = IntervalAlgSet(1, 2)\r\n    s3 = IntervalAlgSet(2, 3)\r\n    s4 = DiscreteAlgSet(1)\r\n    s5 = DiscreteAlgSet(2)\r\n    union_result1 = AlgSet.union(s1, s2, s4)\r\n    union_result2 = AlgSet.union(s1, s2)\r\n    union_result3 = UnionAlgSet(union_result2)\r\n    union_result4 = AlgSet.union(s4, s5, s3)\r\n    print(union_result1)\r\n    print(union_result2)\r\n    print(union_result3)\r\n    print(union_result4)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algsettools/algset.py b/algsettools/algset.py
--- a/algsettools/algset.py	(revision e0ae38b29b3dbfb62d4685580ce6bac30e683b6c)
+++ b/algsettools/algset.py	(date 1700328352172)
@@ -183,7 +183,7 @@
                     return IntervalAlgSet(l2, u1, l2_closed, True)
             case _:
                 intersection_not_recognized: str = ErrorMessages.replace(ErrorMessages.INTERSECTION_NOT_RECOGNIZED,
-                                                                         (interval1, interval2))
+                                                                         interval1, interval2)
                 raise ValueError(f"{AlgSet._ERR}{intersection_not_recognized}")
 
     @staticmethod
@@ -458,7 +458,7 @@
                     return IntervalAlgSet(l1, u1, l1_closed, True)
             case _:
                 intersection_not_recognized: str = ErrorMessages.replace(ErrorMessages.INTERSECTION_NOT_RECOGNIZED,
-                                                                         (interval1, interval2))
+                                                                         interval1, interval2)
                 raise ValueError(f"{AlgSet._ERR}{intersection_not_recognized}")
 
     @staticmethod
Index: algexptools/numericatomicalgexp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import Any\r\nimport re\r\n\r\nfrom algebradata import AlgebraData as Ad\r\nfrom errormessages import ErrorMessages\r\nfrom algexptools import AtomicAlgExp, NumericAlgExp\r\nfrom patterns import Patterns\r\n\r\n\r\nclass NumericAtomicAlgExp(NumericAlgExp, AtomicAlgExp):\r\n    \"\"\"\r\n    Contains a real number without any operations or 'i' / '-i'.\r\n    \"\"\"\r\n\r\n    _PREFIX: str = \"NumericAtomicAlgExp\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # other variables\r\n    _allowed_content_pattern = re.compile(Patterns.ALLOWED_NUMERIC_ATOMIC_CONTENT)\r\n\r\n    def __init__(self, expression: Any = 0):\r\n        self._correction_methods = (self._remove_zeros,)\r\n        NumericAlgExp.__init__(self, expression)\r\n\r\n    @property\r\n    def value(self) -> complex:\r\n        i, minus_i = Ad.IMAG_UNIT, f\"{Ad.MINUS}{Ad.IMAG_UNIT}\"\r\n        if self._content in (i, minus_i):\r\n            return complex(self._content.replace(i, Ad.IMAG_UNIT_BUILT_IN))\r\n        return complex(self._content)\r\n\r\n    def is_natural(self) -> bool:\r\n        return not self.has_imag() and self.value.real > 0\r\n\r\n    def is_integer(self) -> bool:\r\n        return not self.has_imag()\r\n\r\n    def is_rational(self) -> bool:\r\n        return not self.has_imag()\r\n\r\n    def is_real(self) -> bool:\r\n        return not self.has_imag()\r\n\r\n    def is_complex(self) -> bool:\r\n        return True\r\n\r\n    def _create_content_from_complex(self, expression: complex) -> None:\r\n        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ATOMIC, expression)\r\n        assert expression.real == 0 or expression.imag == 0, f\"{self._ERR}{is_not_atomic}\"\r\n        if expression.real:  # further, the creation is delegated to the float method\r\n            self._create_content_from_float(expression.real)\r\n        else:  # multiple of imag unit must be -1, 0 or 1\r\n            assert expression.imag in (-1, 0, 1), f\"{self._ERR}{is_not_atomic}\"\r\n            match expression.imag:\r\n                case -1:\r\n                    self._content = f\"{Ad.MINUS}{Ad.IMAG_UNIT}\"\r\n                case 0:\r\n                    self._content = \"0\"\r\n                case 1:\r\n                    self._content = Ad.IMAG_UNIT\r\n\r\n    def _create_content_from_float(self, expression: float) -> None:\r\n        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ATOMIC, expression)\r\n        for special_string in Ad.SPECIAL_NUMERIC_STRINGS:\r\n            if str(expression) in (special_string, f\"{Ad.MINUS}{special_string}\"):\r\n                self._content = str(expression)\r\n                return\r\n        assert expression % 1 == 0, f\"{self._ERR}{is_not_atomic}\"  # expression must be an integer\r\n        self._content = str(expression)[:-2]\r\n\r\n    def _create_content_from_str(self, expression: str) -> None:\r\n        corrected_expression: str = self._correction(expression)\r\n        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ATOMIC, expression)\r\n        assert re.search(self._allowed_content_pattern, corrected_expression), f\"{self._ERR}{is_not_atomic}\"\r\n        if re.search(Patterns.FLOAT_NUMBER, corrected_expression):\r\n            self._create_content_from_float(float(corrected_expression))\r\n        else:\r\n            self._content = corrected_expression\r\n\r\n    def _init_check(self, expression: Any, variables_domains: dict = None) -> None:\r\n        i, minus_i = Ad.IMAG_UNIT, f\"{Ad.MINUS}{Ad.IMAG_UNIT}\"\r\n        clean_expression: str\r\n        if isinstance(expression, str):\r\n            clean_expression = self._remove_white_spaces(expression)\r\n        else:\r\n            clean_expression = expression\r\n        self._allowed_types = {int: self.__create_content_from_int}\r\n        self._asserts = [\r\n            (\r\n                not isinstance(expression, str) or re.search(self._allowed_content_pattern, clean_expression),\r\n                f\"Expression must be a real number without operations or '{i}' / '{minus_i}' (see doc)\")\r\n        ]\r\n        super()._init_check(expression)\r\n\r\n    def __create_content_from_int(self, expression: int) -> None:\r\n        \"\"\"\r\n        Creates specific structure (named as content) from an expression int.\r\n        :param expression: any algebraic expression\r\n        :return: None\r\n        \"\"\"\r\n        self._content = str(expression)\r\n\r\n    def _substitute_all_special_numeric_strings(self, expression: str, reverse: bool = False) -> str:\r\n        subs_chr, subs_index = Ad.SUBSTITUTION_CHARACTER, self._substitution_index\r\n        substitutions: dict = self._special_numeric_strings_substitutions\r\n        replaced_expression: str = expression\r\n        if reverse:\r\n            for special_string in substitutions:\r\n                replaced_expression = replaced_expression.replace(substitutions[special_string], special_string)\r\n            return replaced_expression\r\n        for special_string in Ad.SPECIAL_NUMERIC_STRINGS:\r\n            if special_string in replaced_expression:\r\n                replaced_expression = replaced_expression.replace(special_string, f\"{subs_chr}{subs_index}\")\r\n                self._special_numeric_strings_substitutions[special_string] = f\"{subs_chr}{subs_index}\"\r\n                break\r\n        return replaced_expression\r\n\r\n\r\nif __name__ == '__main__':\r\n    while True:\r\n        alg_exp_input: str = input(\": \")\r\n        if alg_exp_input == \"exit\":\r\n            break\r\n        try:\r\n            alg_exp: NumericAtomicAlgExp = NumericAtomicAlgExp(alg_exp_input)\r\n            print(f\"exp: {alg_exp}\")\r\n            print(f\"value: {alg_exp.value}\")\r\n        except Exception as err:\r\n            print(err)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algexptools/numericatomicalgexp.py b/algexptools/numericatomicalgexp.py
--- a/algexptools/numericatomicalgexp.py	(revision e0ae38b29b3dbfb62d4685580ce6bac30e683b6c)
+++ b/algexptools/numericatomicalgexp.py	(date 1700328353186)
@@ -45,7 +45,7 @@
         return True
 
     def _create_content_from_complex(self, expression: complex) -> None:
-        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ATOMIC, expression)
+        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, AtomicAlgExp.__name__)
         assert expression.real == 0 or expression.imag == 0, f"{self._ERR}{is_not_atomic}"
         if expression.real:  # further, the creation is delegated to the float method
             self._create_content_from_float(expression.real)
@@ -60,7 +60,7 @@
                     self._content = Ad.IMAG_UNIT
 
     def _create_content_from_float(self, expression: float) -> None:
-        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ATOMIC, expression)
+        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, AtomicAlgExp.__name__)
         for special_string in Ad.SPECIAL_NUMERIC_STRINGS:
             if str(expression) in (special_string, f"{Ad.MINUS}{special_string}"):
                 self._content = str(expression)
@@ -70,7 +70,7 @@
 
     def _create_content_from_str(self, expression: str) -> None:
         corrected_expression: str = self._correction(expression)
-        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ATOMIC, expression)
+        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, AtomicAlgExp.__name__)
         assert re.search(self._allowed_content_pattern, corrected_expression), f"{self._ERR}{is_not_atomic}"
         if re.search(Patterns.FLOAT_NUMBER, corrected_expression):
             self._create_content_from_float(float(corrected_expression))
Index: algexptools/variableatomicalgexp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import Any\r\nimport re\r\n\r\nfrom algebradata import AlgebraData as Ad\r\nfrom algexptools import AtomicAlgExp, VariableAlgExp\r\nfrom errormessages import ErrorMessages\r\nfrom patterns import Patterns\r\n\r\n\r\nclass VariableAtomicAlgExp(VariableAlgExp, AtomicAlgExp):\r\n    \"\"\"\r\n    Contains variable without any operations.\r\n    \"\"\"\r\n\r\n    _PREFIX: str = \"VariableAtomicAlgExp\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # other variables\r\n    _allowed_content_pattern = re.compile(Patterns.ALLOWED_SIMPLE_VARIABLE_ATOMIC_CONTENT)\r\n\r\n    def __init__(self, expression: Any, variables_domains: dict = None):\r\n        self._correction_methods = ()\r\n        VariableAlgExp.__init__(self, expression, variables_domains)\r\n\r\n    @property\r\n    def normalized_variable(self):\r\n        if self._content.startswith(Ad.MINUS):\r\n            return self._content[1:]\r\n        return self._content\r\n\r\n    def is_minus_variable(self):\r\n        return self._content.startswith(Ad.MINUS)\r\n\r\n    def _create_content_from_str(self, expression: str) -> None:\r\n        minus: str = Ad.MINUS\r\n        left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET\r\n        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ATOMIC, expression)\r\n        corrected_expression: str = self._correction(expression)\r\n        is_minus: bool = corrected_expression.startswith(f\"{minus}{left_imm_br}\")\r\n        if is_minus:\r\n            corrected_expression = corrected_expression[1:]\r\n        assert self._is_wrapped_in_brackets(corrected_expression, left_imm_br, right_imm_br) or re.search(\r\n            self._allowed_content_pattern, corrected_expression), f\"{self._ERR}{is_not_atomic}\"\r\n        if is_minus:\r\n            corrected_expression = f\"{minus}{corrected_expression}\"\r\n        self._content = corrected_expression\r\n\r\n    def _found_and_get_all_variables(self) -> list:\r\n        return [self.normalized_variable]\r\n\r\n    def _init_check(self, expression: Any, variables_domains: dict = None) -> None:\r\n        self._allowed_types = {}\r\n        self._asserts = [\r\n            (\r\n                not isinstance(expression, str) or Ad.LEFT_IMMUTABLE_BRACKET in expression or re.search(\r\n                    self._allowed_content_pattern, self._replace_immutable_areas(expression)),\r\n                \"Expression must be a variable without any operations (see doc)\")\r\n        ]\r\n        super()._init_check(expression)\r\n\r\n    @staticmethod\r\n    def _substitute(alg_exp, variable: str, number: Any):\r\n        super()._substitute(alg_exp, variable, number)\r\n        number_string: str = str(number)\r\n        if isinstance(alg_exp, VariableAtomicAlgExp):\r\n            if alg_exp.normalized_variable == variable:\r\n                if alg_exp.is_minus_variable():\r\n                    if number_string.startswith(Ad.MINUS):  # minus and minus is plus\r\n                        alg_exp._content = number_string[1:]\r\n                    else:  # minus and plus is minus\r\n                        alg_exp._content = f\"{Ad.MINUS}{number_string}\"\r\n                else:\r\n                    alg_exp._content = number_string\r\n        return alg_exp\r\n\r\n\r\nif __name__ == '__main__':\r\n    while True:\r\n        alg_exp_input: str = input(\": \")\r\n        if alg_exp_input == \"exit\":\r\n            break\r\n        try:\r\n            alg_exp_outer: VariableAtomicAlgExp = VariableAtomicAlgExp(alg_exp_input)\r\n            print(f\"exp: {alg_exp_outer}\")\r\n            print(f\"variables_domains: {alg_exp_outer.variables_domains}\")\r\n            print(f\"immutable_contents: {alg_exp_outer.immutable_contents}\")\r\n        except Exception as err:\r\n            print(err)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algexptools/variableatomicalgexp.py b/algexptools/variableatomicalgexp.py
--- a/algexptools/variableatomicalgexp.py	(revision e0ae38b29b3dbfb62d4685580ce6bac30e683b6c)
+++ b/algexptools/variableatomicalgexp.py	(date 1700328352127)
@@ -34,7 +34,7 @@
     def _create_content_from_str(self, expression: str) -> None:
         minus: str = Ad.MINUS
         left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET
-        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_ATOMIC, expression)
+        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, AtomicAlgExp.__name__)
         corrected_expression: str = self._correction(expression)
         is_minus: bool = corrected_expression.startswith(f"{minus}{left_imm_br}")
         if is_minus:
@@ -54,7 +54,7 @@
             (
                 not isinstance(expression, str) or Ad.LEFT_IMMUTABLE_BRACKET in expression or re.search(
                     self._allowed_content_pattern, self._replace_immutable_areas(expression)),
-                "Expression must be a variable without any operations (see doc)")
+                "Expression must be a variable without any operations and signs (see doc)")
         ]
         super()._init_check(expression)
 
Index: .idea/dbnavigator.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"DBNavigator.Project.DataEditorManager\">\r\n    <record-view-column-sorting-type value=\"BY_INDEX\" />\r\n    <value-preview-text-wrapping value=\"true\" />\r\n    <value-preview-pinned value=\"false\" />\r\n  </component>\r\n  <component name=\"DBNavigator.Project.DatabaseEditorStateManager\">\r\n    <last-used-providers />\r\n  </component>\r\n  <component name=\"DBNavigator.Project.DatabaseFileManager\">\r\n    <open-files />\r\n  </component>\r\n  <component name=\"DBNavigator.Project.Settings\">\r\n    <connections />\r\n    <browser-settings>\r\n      <general>\r\n        <display-mode value=\"TABBED\" />\r\n        <navigation-history-size value=\"100\" />\r\n        <show-object-details value=\"false\" />\r\n      </general>\r\n      <filters>\r\n        <object-type-filter>\r\n          <object-type name=\"SCHEMA\" enabled=\"true\" />\r\n          <object-type name=\"USER\" enabled=\"true\" />\r\n          <object-type name=\"ROLE\" enabled=\"true\" />\r\n          <object-type name=\"PRIVILEGE\" enabled=\"true\" />\r\n          <object-type name=\"CHARSET\" enabled=\"true\" />\r\n          <object-type name=\"TABLE\" enabled=\"true\" />\r\n          <object-type name=\"VIEW\" enabled=\"true\" />\r\n          <object-type name=\"MATERIALIZED_VIEW\" enabled=\"true\" />\r\n          <object-type name=\"NESTED_TABLE\" enabled=\"true\" />\r\n          <object-type name=\"COLUMN\" enabled=\"true\" />\r\n          <object-type name=\"INDEX\" enabled=\"true\" />\r\n          <object-type name=\"CONSTRAINT\" enabled=\"true\" />\r\n          <object-type name=\"DATASET_TRIGGER\" enabled=\"true\" />\r\n          <object-type name=\"DATABASE_TRIGGER\" enabled=\"true\" />\r\n          <object-type name=\"SYNONYM\" enabled=\"true\" />\r\n          <object-type name=\"SEQUENCE\" enabled=\"true\" />\r\n          <object-type name=\"PROCEDURE\" enabled=\"true\" />\r\n          <object-type name=\"FUNCTION\" enabled=\"true\" />\r\n          <object-type name=\"PACKAGE\" enabled=\"true\" />\r\n          <object-type name=\"TYPE\" enabled=\"true\" />\r\n          <object-type name=\"TYPE_ATTRIBUTE\" enabled=\"true\" />\r\n          <object-type name=\"ARGUMENT\" enabled=\"true\" />\r\n          <object-type name=\"DIMENSION\" enabled=\"true\" />\r\n          <object-type name=\"CLUSTER\" enabled=\"true\" />\r\n          <object-type name=\"DBLINK\" enabled=\"true\" />\r\n        </object-type-filter>\r\n      </filters>\r\n      <sorting>\r\n        <object-type name=\"COLUMN\" sorting-type=\"NAME\" />\r\n        <object-type name=\"FUNCTION\" sorting-type=\"NAME\" />\r\n        <object-type name=\"PROCEDURE\" sorting-type=\"NAME\" />\r\n        <object-type name=\"ARGUMENT\" sorting-type=\"POSITION\" />\r\n        <object-type name=\"TYPE ATTRIBUTE\" sorting-type=\"POSITION\" />\r\n      </sorting>\r\n      <default-editors>\r\n        <object-type name=\"VIEW\" editor-type=\"SELECTION\" />\r\n        <object-type name=\"PACKAGE\" editor-type=\"SELECTION\" />\r\n        <object-type name=\"TYPE\" editor-type=\"SELECTION\" />\r\n      </default-editors>\r\n    </browser-settings>\r\n    <navigation-settings>\r\n      <lookup-filters>\r\n        <lookup-objects>\r\n          <object-type name=\"SCHEMA\" enabled=\"true\" />\r\n          <object-type name=\"USER\" enabled=\"false\" />\r\n          <object-type name=\"ROLE\" enabled=\"false\" />\r\n          <object-type name=\"PRIVILEGE\" enabled=\"false\" />\r\n          <object-type name=\"CHARSET\" enabled=\"false\" />\r\n          <object-type name=\"TABLE\" enabled=\"true\" />\r\n          <object-type name=\"VIEW\" enabled=\"true\" />\r\n          <object-type name=\"MATERIALIZED VIEW\" enabled=\"true\" />\r\n          <object-type name=\"INDEX\" enabled=\"true\" />\r\n          <object-type name=\"CONSTRAINT\" enabled=\"true\" />\r\n          <object-type name=\"DATASET TRIGGER\" enabled=\"true\" />\r\n          <object-type name=\"DATABASE TRIGGER\" enabled=\"true\" />\r\n          <object-type name=\"SYNONYM\" enabled=\"false\" />\r\n          <object-type name=\"SEQUENCE\" enabled=\"true\" />\r\n          <object-type name=\"PROCEDURE\" enabled=\"true\" />\r\n          <object-type name=\"FUNCTION\" enabled=\"true\" />\r\n          <object-type name=\"PACKAGE\" enabled=\"true\" />\r\n          <object-type name=\"TYPE\" enabled=\"true\" />\r\n          <object-type name=\"DIMENSION\" enabled=\"false\" />\r\n          <object-type name=\"CLUSTER\" enabled=\"false\" />\r\n          <object-type name=\"DBLINK\" enabled=\"true\" />\r\n        </lookup-objects>\r\n        <force-database-load value=\"false\" />\r\n        <prompt-connection-selection value=\"true\" />\r\n        <prompt-schema-selection value=\"true\" />\r\n      </lookup-filters>\r\n    </navigation-settings>\r\n    <dataset-grid-settings>\r\n      <general>\r\n        <enable-zooming value=\"true\" />\r\n        <enable-column-tooltip value=\"true\" />\r\n      </general>\r\n      <sorting>\r\n        <nulls-first value=\"true\" />\r\n        <max-sorting-columns value=\"4\" />\r\n      </sorting>\r\n      <audit-columns>\r\n        <column-names value=\"\" />\r\n        <visible value=\"true\" />\r\n        <editable value=\"false\" />\r\n      </audit-columns>\r\n    </dataset-grid-settings>\r\n    <dataset-editor-settings>\r\n      <text-editor-popup>\r\n        <active value=\"false\" />\r\n        <active-if-empty value=\"false\" />\r\n        <data-length-threshold value=\"100\" />\r\n        <popup-delay value=\"1000\" />\r\n      </text-editor-popup>\r\n      <values-actions-popup>\r\n        <show-popup-button value=\"true\" />\r\n        <element-count-threshold value=\"1000\" />\r\n        <data-length-threshold value=\"250\" />\r\n      </values-actions-popup>\r\n      <general>\r\n        <fetch-block-size value=\"100\" />\r\n        <fetch-timeout value=\"30\" />\r\n        <trim-whitespaces value=\"true\" />\r\n        <convert-empty-strings-to-null value=\"true\" />\r\n        <select-content-on-cell-edit value=\"true\" />\r\n        <large-value-preview-active value=\"true\" />\r\n      </general>\r\n      <filters>\r\n        <prompt-filter-dialog value=\"true\" />\r\n        <default-filter-type value=\"BASIC\" />\r\n      </filters>\r\n      <qualified-text-editor text-length-threshold=\"300\">\r\n        <content-types>\r\n          <content-type name=\"Text\" enabled=\"true\" />\r\n          <content-type name=\"Properties\" enabled=\"true\" />\r\n          <content-type name=\"XML\" enabled=\"true\" />\r\n          <content-type name=\"DTD\" enabled=\"true\" />\r\n          <content-type name=\"HTML\" enabled=\"true\" />\r\n          <content-type name=\"XHTML\" enabled=\"true\" />\r\n          <content-type name=\"SQL\" enabled=\"true\" />\r\n          <content-type name=\"PL/SQL\" enabled=\"true\" />\r\n          <content-type name=\"JSON\" enabled=\"true\" />\r\n          <content-type name=\"JSON5\" enabled=\"true\" />\r\n          <content-type name=\"YAML\" enabled=\"true\" />\r\n        </content-types>\r\n      </qualified-text-editor>\r\n      <record-navigation>\r\n        <navigation-target value=\"VIEWER\" />\r\n      </record-navigation>\r\n    </dataset-editor-settings>\r\n    <code-editor-settings>\r\n      <general>\r\n        <show-object-navigation-gutter value=\"false\" />\r\n        <show-spec-declaration-navigation-gutter value=\"true\" />\r\n        <enable-spellchecking value=\"true\" />\r\n        <enable-reference-spellchecking value=\"false\" />\r\n      </general>\r\n      <confirmations>\r\n        <save-changes value=\"false\" />\r\n        <revert-changes value=\"true\" />\r\n      </confirmations>\r\n    </code-editor-settings>\r\n    <code-completion-settings>\r\n      <filters>\r\n        <basic-filter>\r\n          <filter-element type=\"RESERVED_WORD\" id=\"keyword\" selected=\"true\" />\r\n          <filter-element type=\"RESERVED_WORD\" id=\"function\" selected=\"true\" />\r\n          <filter-element type=\"RESERVED_WORD\" id=\"parameter\" selected=\"true\" />\r\n          <filter-element type=\"RESERVED_WORD\" id=\"datatype\" selected=\"true\" />\r\n          <filter-element type=\"RESERVED_WORD\" id=\"exception\" selected=\"true\" />\r\n          <filter-element type=\"OBJECT\" id=\"schema\" selected=\"true\" />\r\n          <filter-element type=\"OBJECT\" id=\"role\" selected=\"true\" />\r\n          <filter-element type=\"OBJECT\" id=\"user\" selected=\"true\" />\r\n          <filter-element type=\"OBJECT\" id=\"privilege\" selected=\"true\" />\r\n          <user-schema>\r\n            <filter-element type=\"OBJECT\" id=\"table\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"materialized view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"index\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"constraint\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"trigger\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"synonym\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"sequence\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"procedure\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"function\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"package\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"type\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dimension\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"cluster\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dblink\" selected=\"true\" />\r\n          </user-schema>\r\n          <public-schema>\r\n            <filter-element type=\"OBJECT\" id=\"table\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"view\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"materialized view\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"index\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"constraint\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"trigger\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"synonym\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"sequence\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"procedure\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"function\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"package\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"type\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"dimension\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"cluster\" selected=\"false\" />\r\n            <filter-element type=\"OBJECT\" id=\"dblink\" selected=\"false\" />\r\n          </public-schema>\r\n          <any-schema>\r\n            <filter-element type=\"OBJECT\" id=\"table\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"materialized view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"index\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"constraint\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"trigger\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"synonym\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"sequence\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"procedure\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"function\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"package\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"type\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dimension\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"cluster\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dblink\" selected=\"true\" />\r\n          </any-schema>\r\n        </basic-filter>\r\n        <extended-filter>\r\n          <filter-element type=\"RESERVED_WORD\" id=\"keyword\" selected=\"true\" />\r\n          <filter-element type=\"RESERVED_WORD\" id=\"function\" selected=\"true\" />\r\n          <filter-element type=\"RESERVED_WORD\" id=\"parameter\" selected=\"true\" />\r\n          <filter-element type=\"RESERVED_WORD\" id=\"datatype\" selected=\"true\" />\r\n          <filter-element type=\"RESERVED_WORD\" id=\"exception\" selected=\"true\" />\r\n          <filter-element type=\"OBJECT\" id=\"schema\" selected=\"true\" />\r\n          <filter-element type=\"OBJECT\" id=\"user\" selected=\"true\" />\r\n          <filter-element type=\"OBJECT\" id=\"role\" selected=\"true\" />\r\n          <filter-element type=\"OBJECT\" id=\"privilege\" selected=\"true\" />\r\n          <user-schema>\r\n            <filter-element type=\"OBJECT\" id=\"table\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"materialized view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"index\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"constraint\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"trigger\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"synonym\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"sequence\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"procedure\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"function\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"package\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"type\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dimension\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"cluster\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dblink\" selected=\"true\" />\r\n          </user-schema>\r\n          <public-schema>\r\n            <filter-element type=\"OBJECT\" id=\"table\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"materialized view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"index\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"constraint\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"trigger\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"synonym\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"sequence\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"procedure\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"function\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"package\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"type\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dimension\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"cluster\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dblink\" selected=\"true\" />\r\n          </public-schema>\r\n          <any-schema>\r\n            <filter-element type=\"OBJECT\" id=\"table\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"materialized view\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"index\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"constraint\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"trigger\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"synonym\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"sequence\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"procedure\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"function\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"package\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"type\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dimension\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"cluster\" selected=\"true\" />\r\n            <filter-element type=\"OBJECT\" id=\"dblink\" selected=\"true\" />\r\n          </any-schema>\r\n        </extended-filter>\r\n      </filters>\r\n      <sorting enabled=\"true\">\r\n        <sorting-element type=\"RESERVED_WORD\" id=\"keyword\" />\r\n        <sorting-element type=\"RESERVED_WORD\" id=\"datatype\" />\r\n        <sorting-element type=\"OBJECT\" id=\"column\" />\r\n        <sorting-element type=\"OBJECT\" id=\"table\" />\r\n        <sorting-element type=\"OBJECT\" id=\"view\" />\r\n        <sorting-element type=\"OBJECT\" id=\"materialized view\" />\r\n        <sorting-element type=\"OBJECT\" id=\"index\" />\r\n        <sorting-element type=\"OBJECT\" id=\"constraint\" />\r\n        <sorting-element type=\"OBJECT\" id=\"trigger\" />\r\n        <sorting-element type=\"OBJECT\" id=\"synonym\" />\r\n        <sorting-element type=\"OBJECT\" id=\"sequence\" />\r\n        <sorting-element type=\"OBJECT\" id=\"procedure\" />\r\n        <sorting-element type=\"OBJECT\" id=\"function\" />\r\n        <sorting-element type=\"OBJECT\" id=\"package\" />\r\n        <sorting-element type=\"OBJECT\" id=\"type\" />\r\n        <sorting-element type=\"OBJECT\" id=\"dimension\" />\r\n        <sorting-element type=\"OBJECT\" id=\"cluster\" />\r\n        <sorting-element type=\"OBJECT\" id=\"dblink\" />\r\n        <sorting-element type=\"OBJECT\" id=\"schema\" />\r\n        <sorting-element type=\"OBJECT\" id=\"role\" />\r\n        <sorting-element type=\"OBJECT\" id=\"user\" />\r\n        <sorting-element type=\"RESERVED_WORD\" id=\"function\" />\r\n        <sorting-element type=\"RESERVED_WORD\" id=\"parameter\" />\r\n      </sorting>\r\n      <format>\r\n        <enforce-code-style-case value=\"true\" />\r\n      </format>\r\n    </code-completion-settings>\r\n    <execution-engine-settings>\r\n      <statement-execution>\r\n        <fetch-block-size value=\"100\" />\r\n        <execution-timeout value=\"20\" />\r\n        <debug-execution-timeout value=\"600\" />\r\n        <focus-result value=\"false\" />\r\n        <prompt-execution value=\"false\" />\r\n      </statement-execution>\r\n      <script-execution>\r\n        <command-line-interfaces />\r\n        <execution-timeout value=\"300\" />\r\n      </script-execution>\r\n      <method-execution>\r\n        <execution-timeout value=\"30\" />\r\n        <debug-execution-timeout value=\"600\" />\r\n        <parameter-history-size value=\"10\" />\r\n      </method-execution>\r\n    </execution-engine-settings>\r\n    <operation-settings>\r\n      <transactions>\r\n        <uncommitted-changes>\r\n          <on-project-close value=\"ASK\" />\r\n          <on-disconnect value=\"ASK\" />\r\n          <on-autocommit-toggle value=\"ASK\" />\r\n        </uncommitted-changes>\r\n        <multiple-uncommitted-changes>\r\n          <on-commit value=\"ASK\" />\r\n          <on-rollback value=\"ASK\" />\r\n        </multiple-uncommitted-changes>\r\n      </transactions>\r\n      <session-browser>\r\n        <disconnect-session value=\"ASK\" />\r\n        <kill-session value=\"ASK\" />\r\n        <reload-on-filter-change value=\"false\" />\r\n      </session-browser>\r\n      <compiler>\r\n        <compile-type value=\"KEEP\" />\r\n        <compile-dependencies value=\"ASK\" />\r\n        <always-show-controls value=\"false\" />\r\n      </compiler>\r\n      <debugger>\r\n        <debugger-type value=\"JDBC\" />\r\n        <use-generic-runners value=\"true\" />\r\n      </debugger>\r\n    </operation-settings>\r\n    <ddl-file-settings>\r\n      <extensions>\r\n        <mapping file-type-id=\"VIEW\" extensions=\"vw\" />\r\n        <mapping file-type-id=\"TRIGGER\" extensions=\"trg\" />\r\n        <mapping file-type-id=\"PROCEDURE\" extensions=\"prc\" />\r\n        <mapping file-type-id=\"FUNCTION\" extensions=\"fnc\" />\r\n        <mapping file-type-id=\"PACKAGE\" extensions=\"pkg\" />\r\n        <mapping file-type-id=\"PACKAGE_SPEC\" extensions=\"pks\" />\r\n        <mapping file-type-id=\"PACKAGE_BODY\" extensions=\"pkb\" />\r\n        <mapping file-type-id=\"TYPE\" extensions=\"tpe\" />\r\n        <mapping file-type-id=\"TYPE_SPEC\" extensions=\"tps\" />\r\n        <mapping file-type-id=\"TYPE_BODY\" extensions=\"tpb\" />\r\n      </extensions>\r\n      <general>\r\n        <lookup-ddl-files value=\"true\" />\r\n        <create-ddl-files value=\"false\" />\r\n        <synchronize-ddl-files value=\"true\" />\r\n        <use-qualified-names value=\"false\" />\r\n        <make-scripts-rerunnable value=\"true\" />\r\n      </general>\r\n    </ddl-file-settings>\r\n    <general-settings>\r\n      <regional-settings>\r\n        <date-format value=\"MEDIUM\" />\r\n        <number-format value=\"UNGROUPED\" />\r\n        <locale value=\"SYSTEM_DEFAULT\" />\r\n        <use-custom-formats value=\"false\" />\r\n      </regional-settings>\r\n      <environment>\r\n        <environment-types>\r\n          <environment-type id=\"development\" name=\"Development\" description=\"Development environment\" color=\"-2430209/-12296320\" readonly-code=\"false\" readonly-data=\"false\" />\r\n          <environment-type id=\"integration\" name=\"Integration\" description=\"Integration environment\" color=\"-2621494/-12163514\" readonly-code=\"true\" readonly-data=\"false\" />\r\n          <environment-type id=\"production\" name=\"Production\" description=\"Productive environment\" color=\"-11574/-10271420\" readonly-code=\"true\" readonly-data=\"true\" />\r\n          <environment-type id=\"other\" name=\"Other\" description=\"\" color=\"-1576/-10724543\" readonly-code=\"false\" readonly-data=\"false\" />\r\n        </environment-types>\r\n        <visibility-settings>\r\n          <connection-tabs value=\"true\" />\r\n          <dialog-headers value=\"true\" />\r\n          <object-editor-tabs value=\"true\" />\r\n          <script-editor-tabs value=\"false\" />\r\n          <execution-result-tabs value=\"true\" />\r\n        </visibility-settings>\r\n      </environment>\r\n    </general-settings>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/dbnavigator.xml b/.idea/dbnavigator.xml
--- a/.idea/dbnavigator.xml	(revision e0ae38b29b3dbfb62d4685580ce6bac30e683b6c)
+++ b/.idea/dbnavigator.xml	(date 1700328453569)
@@ -2,7 +2,7 @@
 <project version="4">
   <component name="DBNavigator.Project.DataEditorManager">
     <record-view-column-sorting-type value="BY_INDEX" />
-    <value-preview-text-wrapping value="true" />
+    <value-preview-text-wrapping value="false" />
     <value-preview-pinned value="false" />
   </component>
   <component name="DBNavigator.Project.DatabaseEditorStateManager">
@@ -10,6 +10,9 @@
   </component>
   <component name="DBNavigator.Project.DatabaseFileManager">
     <open-files />
+  </component>
+  <component name="DBNavigator.Project.ExecutionManager">
+    <retain-sticky-names value="false" />
   </component>
   <component name="DBNavigator.Project.Settings">
     <connections />
Index: errormessages.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from algebradata import AlgebraData as Ad\r\nfrom typing import Any\r\n\r\n\r\nclass ErrorMessages:\r\n    __sub_chr: str = Ad.SUBSTITUTION_CHARACTER\r\n    AT_LEAST_TWO_SETS_FOR_INTERSECTION: str = \"At least two sets must be entered to find their intersection\"\r\n    AT_LEAST_TWO_SETS_FOR_UNION: str = \"At least two sets must be entered to find their union\"\r\n    AT_LEAST_TWO_SETS_IN_UNION: str = \"Number of sets in UnionAlgSet must be at least 2\"\r\n    CANNOT_COMPARE_EXPS: str = f\"Expressions '{__sub_chr}1' and '{__sub_chr}2' cannot be compared\"\r\n    CANNOT_COMPUTE_VALUE_UNKNOWN_OPERATOR: str = f\"Cannot compute value with unknown '{__sub_chr}1' operator\"\r\n    CANNOT_DETERMINE_DOMAIN: str = f\"Cannot determine number system domain for expression '{__sub_chr}1'\"\r\n    CANNOT_DIV_BY_ZERO: str = \"Cannot be divided by zero\"\r\n    CANNOT_EMPTY_INTERVAL: str = \"Interval cannot be empty\"\r\n    CANNOT_FOUND_VALUE: str = f\"Value of expression '{__sub_chr}1' cannot be found out\"\r\n    CANNOT_IMAG_IN_INTERVAL: str = \"Interval must not contain any complex numbers with a non-zero imaginary unit\"\r\n    CANNOT_NAN_IN_INTERVAL: str = \"Interval must not contain nan\"\r\n    WRONG_NUMBERS_ORDERING_INTERVAL: str = f\"Ordering of the numbers does not follow the interval rules in interval {__sub_chr}1\"\r\n    EXP_NOT_BELONG_TO_SET: str = f\"Expression '{__sub_chr}1' does not belong to the number system domain: '{__sub_chr}2'\"\r\n    EXP_NOT_IN_SET: str = f\"Expression '{__sub_chr}1' is not in set {__sub_chr}2\"\r\n    INTERSECTION_NOT_RECOGNIZED: str = f\"Intersection of intervals {__sub_chr}1 and {__sub_chr}2 not recognized\"\r\n    INTERVAL_MUST_BE_CLOSED: str = f\"Interval {__sub_chr}1 must be closed\"\r\n    IS_NOT_ALG_EXP: str = f\"Expression '{__sub_chr}1' is not in the correct form for AlgExp\"\r\n    IS_NOT_ATOMIC: str = f\"Expression '{__sub_chr}1' is not in the correct form for AtomicAlgExp\"\r\n    IS_NOT_COMPOSITE: str = f\"Expression '{__sub_chr}1' is not in the correct form for CompositeAlgExp\"\r\n    IS_NOT_VARIABLE: str = f\"Expression '{__sub_chr}1' is not in the correct form for VariableAlgExp\"\r\n    LEN_INTERVAL_MUST_BE_2: str = \"Length of interval must be 2\"\r\n    EXP_MUST_BE_INSTANCE: str = f\"Expression must be instance of {__sub_chr}1\"\r\n    NUMBER_MUST_BE_INSTANCE: str = f\"number must be instance of {__sub_chr}1\"\r\n    SET_MUST_BE_INSTANCE: str = f\"set must be an instance of {__sub_chr}1\"\r\n    MUST_BE_INTEGER: str = \"Number for substitution must be an integer\"\r\n    MUST_CONTAIN_VARIABLE: str = \"VariableComposite expression must contain any variable\"\r\n    SET_MUST_NOT_CONTAIN_VARS: str = \"AlgSet must not contain any instance of VariableAlgExp\"\r\n    TYPE_FOR_ITEM_IN_CONTAINS: str = \"item must be instance of int or str\"\r\n    UNION_MUST_CONTAIN_INTERVAL: str = \"UnionAlgSet must contain any interval\"\r\n    VAR_HAS_EMPTY_SET_DOMAIN: str = f\"Domain of a variable '{__sub_chr}1' is an empty set\"\r\n    WRONG_INTERVAL: str = f\"Wrong interval '{__sub_chr}1' for number system domain: '{__sub_chr}2'\"\r\n\r\n    @staticmethod\r\n    def replace(message: str, strings_to_replace: Any) -> str:\r\n        sub: str = ErrorMessages.__sub_chr\r\n        if not isinstance(strings_to_replace, (list, tuple)):\r\n            return message.replace(f\"{sub}1\", str(strings_to_replace))\r\n        replaced_string: str = message\r\n        for i, string_to_replace in enumerate(strings_to_replace):\r\n            replaced_string = replaced_string.replace(f\"{sub}{i + 1}\", str(string_to_replace))\r\n        return replaced_string\r\n    
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/errormessages.py b/errormessages.py
--- a/errormessages.py	(revision e0ae38b29b3dbfb62d4685580ce6bac30e683b6c)
+++ b/errormessages.py	(date 1700328352160)
@@ -37,12 +37,10 @@
     WRONG_INTERVAL: str = f"Wrong interval '{__sub_chr}1' for number system domain: '{__sub_chr}2'"
 
     @staticmethod
-    def replace(message: str, strings_to_replace: Any) -> str:
+    def replace(message: str, *args) -> str:
         sub: str = ErrorMessages.__sub_chr
-        if not isinstance(strings_to_replace, (list, tuple)):
-            return message.replace(f"{sub}1", str(strings_to_replace))
         replaced_string: str = message
-        for i, string_to_replace in enumerate(strings_to_replace):
+        for i, string_to_replace in enumerate(args):
             replaced_string = replaced_string.replace(f"{sub}{i + 1}", str(string_to_replace))
         return replaced_string
     
\ No newline at end of file
