Index: algexptools/algexp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC, abstractmethod\r\nfrom inspect import isabstract\r\nimport re\r\nfrom typing import Any, Tuple\r\n\r\nfrom algebradata import AlgebraData as Ad\r\nfrom errormessages import ErrorMessages\r\nfrom patterns import Patterns\r\n\r\n\r\nclass AlgExp(ABC):\r\n    \"\"\"\r\n    Abstract class for all kinds of algebraic expressions:\r\n\r\n    - NumericAtomicAlgExp     numeric expression without operations\r\n    - NumericCompositeAlgExp  numeric expression with operations\r\n    - VariableAtomicAlgExp    variable expression without operations\r\n    - VariableCompositeAlgExp variable expression with operations\r\n    \"\"\"\r\n    _PREFIX: str = \"AlgExp\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # common variables\r\n    _content: list | str = None\r\n\r\n    # other variables\r\n    _allowed_content_pattern: re = None\r\n    _allowed_types: dict = None\r\n    _asserts: list = None\r\n    _correction_methods: tuple = None\r\n    _special_numeric_strings_substitutions: dict = None\r\n    _substitution_index: int = None\r\n\r\n    def __init__(self, expression: Any):\r\n        self._correction_methods = (self._remove_white_spaces, self._remove_redundant_pluses_minuses,\r\n                                    self._remove_outer_brackets) + self._correction_methods\r\n        self._special_numeric_strings_substitutions = {}\r\n        self._substitution_index = 1\r\n        self._init_check(expression)\r\n        self._create_content(expression)\r\n\r\n    @abstractmethod\r\n    def __str__(self):\r\n        return NotImplemented\r\n\r\n    @abstractmethod\r\n    def has_imag(self) -> bool:\r\n        \"\"\"\r\n        If expression contains an imaginary unit, returns True.\r\n        Otherwise, returns False.\r\n        :return: see doc\r\n        \"\"\"\r\n        return NotImplemented\r\n\r\n    @abstractmethod\r\n    def _create_content_from_str(self, expression: str):\r\n        \"\"\"\r\n        Creates specific structure (named as content) from an expression string.\r\n        :param expression: any algebraic expression\r\n        :return: None\r\n        \"\"\"\r\n        return NotImplemented\r\n\r\n    def __add__(self, other):\r\n        return self.__magic_operation_method_result(other, Ad.PLUS)\r\n\r\n    def __contains__(self, item: int | str):\r\n        assert isinstance(item, (int, str)), f\"{self._ERR}{ErrorMessages.TYPE_FOR_ITEM_IN_CONTAINS}\"\r\n\r\n    def __mul__(self, other):\r\n        return self.__magic_operation_method_result(other, Ad.MULTIPLY)\r\n\r\n    def __neg__(self):\r\n        from algexptools import AtomicAlgExp\r\n        if isinstance(self, AtomicAlgExp):\r\n            return AlgExp.initializer(f\"{Ad.MINUS}{self}\")\r\n        return AlgExp.initializer(f\"{Ad.MINUS}{Ad.LEFT_BRACKET}{self}{Ad.RIGHT_BRACKET}\")\r\n\r\n    def __pos__(self):\r\n        return AlgExp.initializer(self)\r\n\r\n    def __pow__(self, power, modulo=None):\r\n        return self.__magic_operation_method_result(power, Ad.POWER)\r\n\r\n    def __radd__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__add__)\r\n\r\n    def __repr__(self):\r\n        return str(self)\r\n\r\n    def __rmul__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__mul__)\r\n\r\n    def __rpow__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__pow__)\r\n\r\n    def __rsub__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__sub__)\r\n\r\n    def __rtruediv__(self, other):\r\n        return self.__magic_operation_method_r_result(other, AlgExp.__truediv__)\r\n\r\n    def __sub__(self, other):\r\n        return self.__magic_operation_method_result(other, Ad.MINUS)\r\n\r\n    def __truediv__(self, other):\r\n        return self.__magic_operation_method_result(other, Ad.DIV)\r\n\r\n    @property\r\n    def content(self):\r\n        return self._content\r\n\r\n    def _correction(self, expression: str) -> str:\r\n        \"\"\"\r\n        With the correction methods given for each instance, it corrects\r\n        the string expression to create content.\r\n        :param expression: any algebraic expression\r\n        :return: string expression in the correct format to create content\r\n        \"\"\"\r\n        # substitute all special numeric strings\r\n        expression = self._substitute_all_special_numeric_strings(expression)\r\n        original_expression: str = \"\"\r\n        while expression != original_expression:\r\n            original_expression = expression\r\n            for method in self._correction_methods:\r\n                expression = method(expression)\r\n        # reverse substitute all special numeric strings\r\n        expression = self._substitute_all_special_numeric_strings(expression, reverse=True)\r\n        return expression\r\n\r\n    def _create_content(self, expression: Any) -> None:\r\n        \"\"\"\r\n        Creates content based one the type of an algebraic expression.\r\n        :param expression: any algebraic expression\r\n        :return: None\r\n        \"\"\"\r\n        self._allowed_types[type(expression)](expression)\r\n\r\n    def _create_content_from_other_instance(self, expression) -> None:\r\n        \"\"\"\r\n        Creates content from other instance of an algebraic expression.\r\n        :param expression: any algebraic expression\r\n        :return: None\r\n        \"\"\"\r\n        must_be_instance: str = ErrorMessages.replace(ErrorMessages.MUST_BE_INSTANCE, \"Expression\",\r\n                                                      self.__class__.__name__)\r\n        assert isinstance(expression, self.__class__), f\"{self._ERR}{must_be_instance}\"\r\n        self._content = expression.content\r\n\r\n    def _init_check(self, expression: Any, variables_domains: dict = None) -> None:\r\n        \"\"\"\r\n        Sniper filter for throwing an exception if the parameters are invalid.\r\n        :param expression: any algebraic expression\r\n        :param variables_domains: definition domains of variables\r\n        :return: None\r\n        \"\"\"\r\n        left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET\r\n        new_allowed_types: dict = {str: self._create_content_from_str,\r\n                                   self.__class__: self._create_content_from_other_instance}\r\n        self._allowed_types.update(new_allowed_types)\r\n        types_string: str = \"(\" + \", \".join([x.__name__ for x in self._allowed_types]) + \")\"\r\n        new_asserts: list = [\r\n            (isinstance(expression, tuple(self._allowed_types)),\r\n             f\"expression must be in {types_string}\"),\r\n            (not isinstance(expression, str) or expression.count(left_br) == expression.count(right_br),\r\n             f\"The numbers of '{left_br}' and '{right_br}' brackets must be the same.\"),\r\n        ]\r\n        self._asserts += new_asserts\r\n        for condition, err_message in self._asserts:\r\n            assert condition, f\"{self._ERR}{err_message}\"\r\n\r\n    def _is_wrapped_in_brackets(self, expression: str, left_br: str = Ad.LEFT_BRACKET,\r\n                                right_br: str = Ad.RIGHT_BRACKET) -> bool:\r\n        \"\"\"\r\n        Returns True if the whole expression is wrapped in brackets.\r\n        Otherwise, returns False.\r\n        :param expression: any algebraic expression\r\n        :param left_br: some type of left bracket\r\n        :param right_br: some type of right bracket\r\n        :return: see doc\r\n        \"\"\"\r\n        analyzed_brackets: list = [(left_br, right_br)]\r\n        if len(expression) > 2 and self._bracketing(expression, analyzed_brackets).count(0) == 1:\r\n            return True\r\n        return False\r\n\r\n    def _remove_outer_brackets(self, expression: str) -> str:\r\n        \"\"\"\r\n        Returns an expression without unnecessary brackets.\r\n        :param expression: any algebraic expression\r\n        :return: see doc\r\n        \"\"\"\r\n        while self._is_wrapped_in_brackets(expression):\r\n            expression = expression[1:-1]\r\n        return expression\r\n\r\n    def _substitute_all_special_numeric_strings(self, expression: str, reverse: bool = False) -> str:\r\n        \"\"\"\r\n        Substitutes all special numeric strings in expression.\r\n        :param expression: any algebraic expression\r\n        :param reverse: flag for reverse substitution\r\n        :return: expression with substituted special numeric strings\r\n        \"\"\"\r\n        substitutions: dict = self._special_numeric_strings_substitutions\r\n        replaced_string: str = expression\r\n        if reverse:\r\n            for special_string in substitutions:\r\n                wrapped_subs_string: str = f\"{Ad.LEFT_BRACKET}{substitutions[special_string]}{Ad.RIGHT_BRACKET}\"\r\n                replaced_string = replaced_string.replace(wrapped_subs_string, special_string)\r\n            self._substitution_index = 1\r\n            return replaced_string\r\n        for special_string in Ad.SPECIAL_NUMERIC_STRINGS:\r\n            replaced_string = self.__substitute_special_numeric_string(replaced_string, special_string)\r\n        return replaced_string\r\n\r\n    def __magic_operation_method_result(self, other, operator: str):\r\n        left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET\r\n        exp_other = AlgExp.initializer(other)\r\n        add_result: str = f\"{left_br}{self}{right_br}{operator}{left_br}{exp_other}{right_br}\"\r\n        return AlgExp.initializer(add_result)\r\n\r\n    def __magic_operation_method_r_result(self, other, magic_operation_method):\r\n        exp1 = AlgExp.initializer(other)\r\n        return magic_operation_method(exp1, self)\r\n\r\n    def __substitute_special_numeric_string(self, expression: str, special_string: str) -> str:\r\n        \"\"\"\r\n        Substitutes special numeric string in expression based on allowed patterns in this method.\r\n        After that, returns this substituted expression.\r\n        :param expression: any algebraic expression\r\n        :param special_string: any special string from special numeric strings\r\n        :return: expression with substituted special numeric string\r\n        \"\"\"\r\n        left_br, right_br, i = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET, Ad.IMAG_UNIT\r\n        subs_chr, subs_index = Ad.SUBSTITUTION_CHARACTER, self._substitution_index\r\n        var_chars, var_chars_without_i = Patterns.ALLOWED_VAR_CHARS, Patterns.ALLOWED_VAR_CHARS_WITHOUT_IMAG_UNIT\r\n        replaced_string: str = expression\r\n        subs_string: str = f\"{subs_chr}{subs_index}\"\r\n        allowed_patterns: tuple = (\r\n            rf\"^({special_string})[^{var_chars}]\",\r\n            rf\"[^{var_chars}]({special_string})[^{var_chars}]\",\r\n            rf\"[^{var_chars}]({special_string})$\",\r\n            rf\"^({special_string}){i}\",\r\n            rf\"{i}({special_string})$\",\r\n            rf\"{i}({special_string}){i}\",\r\n            rf\"{i}({special_string})[^{var_chars}]\",\r\n            rf\"[^{var_chars}]({special_string}){i}\",\r\n        )\r\n        pattern_for_special_string = re.compile(\"|\".join(allowed_patterns))\r\n        founds = re.search(pattern_for_special_string, expression)\r\n        if founds is None:\r\n            return expression\r\n        for founds_index in range(1, len(allowed_patterns) + 1):\r\n            if founds.group(founds_index):\r\n                replaced_string = str(\r\n                    re.subn(founds.group(founds_index), f\"{left_br}{subs_string}{right_br}\", replaced_string)[0])\r\n        self._special_numeric_strings_substitutions[special_string] = subs_string\r\n        self._substitution_index += 1\r\n        return replaced_string\r\n\r\n    @staticmethod\r\n    def initializer(expression: Any = 0, *args):\r\n        \"\"\"\r\n        Returns an instance of AlgExp based on classes for initialization.\r\n        :param expression: any algebraic expression\r\n        :param args: classes given to create an instance of AlgExp\r\n        :return: instance of AlgExp\r\n        \"\"\"\r\n        def __all_subclasses(top_cls, allow_abstract: bool = False) -> tuple:\r\n            \"\"\"\r\n            Returns all subclasses of top class.\r\n            If allow_abstract is set on True, then abstract classes are also returned.\r\n            Otherwise, only concrete classes are returned.\r\n            :param top_cls: class from which its subclasses are searched\r\n            :param allow_abstract: flag for abstract classes [False]\r\n            :return: all subclasses of top class (with/without abstract classes depending on allow_abstract)\r\n            \"\"\"\r\n            from algexptools import NumericAtomicAlgExp, NumericCompositeAlgExp, VariableAtomicAlgExp, \\\r\n                VariableCompositeAlgExp\r\n            actual_cls = top_cls\r\n            all_subclasses: tuple = (actual_cls,)\r\n            for cls in actual_cls.__subclasses__():\r\n                all_subclasses += __all_subclasses(cls)\r\n            if not allow_abstract:\r\n                all_subclasses = tuple(cls for cls in all_subclasses if not isabstract(cls))\r\n            return all_subclasses\r\n\r\n        classes_for_init = args\r\n        if classes_for_init == ():\r\n            classes_for_init = __all_subclasses(AlgExp)\r\n        for actual_class in classes_for_init:\r\n            try:\r\n                return actual_class(expression)\r\n            except (AssertionError, ValueError):\r\n                pass\r\n        is_not_alg_exp: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, AlgExp.__name__)\r\n        raise ValueError(f\"{AlgExp._ERR}{is_not_alg_exp}\")\r\n\r\n    @staticmethod\r\n    def _bracketing(expression: str, analyzed_brackets: list = None) -> list:\r\n        \"\"\"\r\n        Returns brackets structure in expression like string.\r\n        Each character is analyzed for its brackets deep level and each such level as a number\r\n        is stored in the bracketing list. Finally, this list is returned.\r\n        e.g. \"a*(b+c)\" => [0, 0, 1, 1, 1, 1, 0]\r\n        e.g. \"2*(1+3)+4*(5-(6+7))\" => [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 1, 0]\r\n        :param expression: any algebraic expression\r\n        :param analyzed_brackets: brackets that are analyzed during bracketing\r\n        :return: list of brackets deep levels for each character in expression string\r\n        \"\"\"\r\n        if analyzed_brackets is None:\r\n            analyzed_brackets = [(Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET)]\r\n        analyzed_left_brackets: Tuple[str] = tuple(brackets_pair[0] for brackets_pair in analyzed_brackets)\r\n        analyzed_right_brackets: Tuple[str] = tuple(brackets_pair[1] for brackets_pair in analyzed_brackets)\r\n        bracketing: list = []\r\n        brackets_level: int = 0\r\n        for character in expression:\r\n            if character in analyzed_left_brackets:\r\n                brackets_level += 1\r\n            elif character in analyzed_right_brackets:\r\n                brackets_level -= 1\r\n            bracketing.append(brackets_level)\r\n        return bracketing\r\n\r\n    @staticmethod\r\n    def _remove_redundant_pluses_minuses(expression: str) -> str:\r\n        \"\"\"\r\n        Removes redundant pluses and minuses based on pattern and replace table in this method.\r\n        Finally, the method removes unnecessary pluses from the beginning of the string\r\n        and all pluses that follow the left bracket.\r\n        :param expression: any algebraic expression\r\n        :return: expression string without redundant pluses and minuses\r\n        \"\"\"\r\n        minus, plus = Ad.MINUS, Ad.PLUS\r\n        left_br: str = Ad.LEFT_BRACKET\r\n        pattern_redundant_pluses_minuses = re.compile(\"[\" + minus + plus + \"]{2}\")\r\n        replace_table: dict = {f\"{minus}{minus}\": plus, f\"{minus}{plus}\": minus, f\"{plus}{minus}\": minus,\r\n                               f\"{plus}{plus}\": plus}\r\n        while re.findall(pattern_redundant_pluses_minuses, expression):\r\n            for redundant_string in replace_table:\r\n                expression = expression.replace(redundant_string, replace_table[redundant_string])\r\n        if expression.startswith(plus):\r\n            expression = expression[1:]\r\n        expression = expression.replace(left_br + plus, left_br)\r\n        return expression\r\n\r\n    @staticmethod\r\n    def _remove_white_spaces(expression: str) -> str:\r\n        \"\"\"\r\n        Removes all white spaces from expression string and after that this replaced string is returned.\r\n        :param expression: any algebraic expression\r\n        :return: expression string without any white spaces\r\n        \"\"\"\r\n        pattern_white_spaces = re.compile(Patterns.WHITE_SPACES)\r\n        return re.sub(pattern_white_spaces, \"\", expression)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algexptools/algexp.py b/algexptools/algexp.py
--- a/algexptools/algexp.py	(revision ef16031017abad120dabbe20597ac78a94c54f95)
+++ b/algexptools/algexp.py	(date 1700766310797)
@@ -275,8 +275,8 @@
             :param allow_abstract: flag for abstract classes [False]
             :return: all subclasses of top class (with/without abstract classes depending on allow_abstract)
             """
-            from algexptools import NumericAtomicAlgExp, NumericCompositeAlgExp, VariableAtomicAlgExp, \
-                VariableCompositeAlgExp
+            # from algexptools import NumericAtomicAlgExp, NumericCompositeAlgExp, VariableAtomicAlgExp, \
+            #     VariableCompositeAlgExp
             actual_cls = top_cls
             all_subclasses: tuple = (actual_cls,)
             for cls in actual_cls.__subclasses__():
Index: algexptools/variablecompositealgexp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from inspect import stack\r\nfrom typing import Any, List, Tuple\r\nimport re\r\n\r\nfrom algebradata import AlgebraData as Ad\r\nfrom algexptools import AlgExp, CompositeAlgExp, NumericAtomicAlgExp, NumericCompositeAlgExp, VariableAlgExp, \\\r\n    VariableAtomicAlgExp\r\nfrom errormessages import ErrorMessages\r\nfrom patterns import Patterns\r\n\r\n\r\nclass VariableCompositeAlgExp(VariableAlgExp, CompositeAlgExp):\r\n    \"\"\"\r\n    Contains variable with at least one operation.\r\n    \"\"\"\r\n\r\n    _PREFIX: str = \"VariableCompositeAlgExp\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # other variables\r\n    _allowed_content_pattern = re.compile(Patterns.ALLOWED_VARIABLE_COMPOSITE_CONTENT)\r\n\r\n    def __init__(self, expression: Any, variables_domains: dict = None):\r\n        self._correction_methods = (self._add_multiply_operators, self._replace_minuses)\r\n        VariableAlgExp.__init__(self, expression, variables_domains)\r\n\r\n    def _alg_exp_structure(self, expression: str) -> list:\r\n        from algexptools import VariableAlgExp\r\n        stack_functions: list = [stack_info.function for stack_info in stack()]\r\n        stack_trace_top_level: bool = stack_functions.count(stack_functions[0]) == 1\r\n        left_br, right_br = Ad.LEFT_BRACKET, Ad.RIGHT_BRACKET\r\n        left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET\r\n        analyzed_brackets: List[Tuple[str, str]] = [(left_br, right_br), (left_imm_br, right_imm_br)]\r\n        is_not_composite: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, CompositeAlgExp.__name__)\r\n        split_indexes: dict = {operator: [] for operator in Ad.OPERATORS}\r\n        expression_parts: list = []\r\n        operator_for_split: str = \"\"\r\n        contains_variable: bool = False\r\n        bracketing: list = self._bracketing(expression, analyzed_brackets)\r\n        for i, deep_level in enumerate(bracketing):\r\n            if deep_level == 0 and expression[i] in Ad.OPERATORS:\r\n                actual_operator: str = expression[i]\r\n                split_indexes[actual_operator].append(i)\r\n        for operator in Ad.OPERATORS:\r\n            if split_indexes[operator]:\r\n                split_indexes[operator].append(len(expression))\r\n                operator_for_split = operator\r\n                start_index: int = 0\r\n                for actual_index in split_indexes[operator_for_split]:\r\n                    inner_alg_exp = AlgExp.initializer(expression[start_index:actual_index])\r\n                    if not contains_variable and isinstance(inner_alg_exp, VariableAlgExp):\r\n                        contains_variable = True\r\n                    expression_parts.append(inner_alg_exp)\r\n                    start_index = actual_index + 1\r\n                break\r\n        if operator_for_split == \"\":\r\n            raise ValueError(f\"{self._ERR}{is_not_composite}\")\r\n        if not contains_variable:\r\n            raise ValueError(f\"{self._ERR}{ErrorMessages.MUST_CONTAIN_VARIABLE}\")\r\n        self._operator = operator_for_split\r\n        variables_contents: list = VariableAlgExp._found_and_get_all_variables_contents(expression_parts)\r\n        self._variables = [VariableAtomicAlgExp(exp) for exp in variables_contents]\r\n        if stack_trace_top_level:\r\n            self.__unify_same_variables(expression_parts)\r\n        return expression_parts\r\n\r\n    def _create_content_from_str(self, expression: str) -> None:\r\n        corrected_expression: str = self._correction(expression)\r\n        self._content = self._alg_exp_structure(corrected_expression)\r\n\r\n    def _init_check(self, expression: Any, variables_domains: dict = None) -> None:\r\n        is_variable_exp: bool = False\r\n        try:\r\n            AlgExp.initializer(expression, NumericAtomicAlgExp, NumericCompositeAlgExp, VariableAtomicAlgExp)\r\n        except ValueError:\r\n            is_variable_exp = True\r\n        self._allowed_types = {}\r\n        self._asserts = [\r\n            (\r\n                not isinstance(expression, str) or Ad.LEFT_IMMUTABLE_BRACKET in expression or re.search(\r\n                    self._allowed_content_pattern, self._replace_immutable_areas(expression)),\r\n                \"Expression must be a variable without any operations (see doc)\"),\r\n            (\r\n                is_variable_exp,\r\n                \"Expression must be a variable without any operations (see doc)\")\r\n        ]\r\n        super()._init_check(expression)\r\n\r\n    def __refresh_variables(self, alg_exp) -> None:\r\n        \"\"\"\r\n        Refreshes instances of variables for alg_exp based on self.variables.\r\n        :param alg_exp: any variable algebraic expression\r\n        :return: None\r\n        \"\"\"\r\n        source_indexes: List[int] = []\r\n        for variable in alg_exp.variables:\r\n            for i, global_instance_variable in enumerate(self.variables):\r\n                if variable.content == global_instance_variable.content:\r\n                    source_indexes.append(i)\r\n        alg_exp._variables = []\r\n        for source_index in source_indexes:\r\n            alg_exp._variables.append(self._variables[source_index])\r\n\r\n    def __unify_same_variables(self, pre_content: list) -> None:\r\n        \"\"\"\r\n        Unifies all instances into a single one for the same variables\r\n        in all expressions inside pre_content.\r\n        :param pre_content: inner part of any instance of VariableCompositeAlgExp\r\n        :return: None\r\n        \"\"\"\r\n        variables_instances_by_content: dict = {variable.content: variable for variable in self._variables}\r\n        substitution_dict: dict = {}\r\n        for i, inner_exp in enumerate(pre_content):\r\n            if isinstance(inner_exp, VariableAlgExp):\r\n                if isinstance(inner_exp, VariableAtomicAlgExp):\r\n                    substitution_dict[i] = variables_instances_by_content[inner_exp.content]\r\n                else:\r\n                    self.__unify_same_variables(inner_exp.content)\r\n                self.__refresh_variables(inner_exp)\r\n        for target_index in substitution_dict:\r\n            pre_content[target_index] = substitution_dict[target_index]\r\n\r\n    @staticmethod\r\n    def _substitute(alg_exp, variable: str, number: Any):\r\n        super()._substitute(alg_exp, variable, number)\r\n        number_string: str = str(number)\r\n        assert re.search(rf\"{Ad.MINUS}?\\d+\", number_string), f\"{AlgExp._ERR}{ErrorMessages.MUST_BE_INTEGER}\"\r\n        if isinstance(alg_exp, VariableCompositeAlgExp):\r\n            for inner_exp in alg_exp.content:\r\n                if isinstance(inner_exp, VariableAlgExp):\r\n                    changed_inner_exp = type(inner_exp)._substitute(inner_exp, variable, number_string)\r\n                    inner_exp._content = changed_inner_exp.content\r\n        return alg_exp\r\n\r\n\r\nif __name__ == '__main__':\r\n    while True:\r\n        alg_exp_input: str = input(\": \")\r\n        if alg_exp_input == \"exit\":\r\n            break\r\n        try:\r\n            alg_exp_outer: VariableCompositeAlgExp = VariableCompositeAlgExp(alg_exp_input)\r\n            print(f\"exp: {alg_exp_outer}\")\r\n            print(f\"variables: {alg_exp_outer.variables}\")\r\n            print(f\"variables_domains: {alg_exp_outer.variables_domains}\")\r\n        except Exception as err:\r\n            print(err)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algexptools/variablecompositealgexp.py b/algexptools/variablecompositealgexp.py
--- a/algexptools/variablecompositealgexp.py	(revision ef16031017abad120dabbe20597ac78a94c54f95)
+++ b/algexptools/variablecompositealgexp.py	(date 1700768628624)
@@ -101,6 +101,15 @@
         for source_index in source_indexes:
             alg_exp._variables.append(self._variables[source_index])
 
+    def __remove_variable_from_all_locations(self, variable):
+        """
+        TODO: write doc
+        :param variable:
+        :return:
+        """
+        variable_for_remove = self.__variable_by_content(variable) if isinstance(variable, str) else variable
+        self.__remove_variable_from_exp_locations(self, variable_for_remove)
+
     def __unify_same_variables(self, pre_content: list) -> None:
         """
         Unifies all instances into a single one for the same variables
@@ -120,6 +129,16 @@
         for target_index in substitution_dict:
             pre_content[target_index] = substitution_dict[target_index]
 
+    def __variable_by_content(self, content: str):
+        """
+        Returns variable from self.variables with same content like content.
+        :param content: string content of variable
+        :return: found variable from self.variables
+        """
+        for variable in self._variables:
+            if variable.content == content:
+                return variable
+
     @staticmethod
     def _substitute(alg_exp, variable: str, number: Any):
         super()._substitute(alg_exp, variable, number)
@@ -132,6 +151,25 @@
                     inner_exp._content = changed_inner_exp.content
         return alg_exp
 
+    @staticmethod
+    def __remove_variable_from_exp_locations(alg_exp, variable) -> None:
+        """
+        Removes all variables locations in all deep levels of alg_exp.
+        :param alg_exp: any variable expression
+        :param variable: any variable from self.variables
+        :return: None
+        """
+        if not isinstance(alg_exp, VariableAlgExp):
+            return
+        if isinstance(alg_exp, VariableCompositeAlgExp):
+            for inner_exp in alg_exp.content:
+                VariableCompositeAlgExp.__remove_variable_from_exp_locations(inner_exp, variable)
+        if variable.content in alg_exp:
+            try:
+                del alg_exp._variables_domains[variable]
+            except Exception as err:
+                print(f"err: {err}")
+
 
 if __name__ == '__main__':
     while True:
Index: algexptools/variableatomicalgexp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import Any\r\nimport re\r\n\r\nfrom algebradata import AlgebraData as Ad\r\nfrom algexptools import AtomicAlgExp, VariableAlgExp\r\nfrom errormessages import ErrorMessages\r\nfrom patterns import Patterns\r\n\r\n\r\nclass VariableAtomicAlgExp(VariableAlgExp, AtomicAlgExp):\r\n    \"\"\"\r\n    Contains variable without any operations.\r\n    \"\"\"\r\n\r\n    _PREFIX: str = \"VariableAtomicAlgExp\"\r\n    _ERR: str = f\"{_PREFIX}Error: \"\r\n\r\n    # other variables\r\n    _allowed_content_pattern = re.compile(Patterns.ALLOWED_SIMPLE_VARIABLE_ATOMIC_CONTENT)\r\n\r\n    def __init__(self, expression: Any, variables_domains: dict = None):\r\n        self._correction_methods = ()\r\n        VariableAlgExp.__init__(self, expression, variables_domains)\r\n\r\n    def _create_content_from_str(self, expression: str) -> None:\r\n        left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET\r\n        is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, AtomicAlgExp.__name__)\r\n        corrected_expression: str = self._correction(expression)\r\n        assert not corrected_expression.startswith(\r\n            f\"{Ad.MINUS}{left_imm_br}\"), f\"{self._ERR}{ErrorMessages.MUST_BE_ATOMIC_VARIABLE}\"\r\n        assert self._is_wrapped_in_brackets(corrected_expression, left_imm_br, right_imm_br) or re.search(\r\n            self._allowed_content_pattern, corrected_expression), f\"{self._ERR}{is_not_atomic}\"\r\n        self._variables = [self]\r\n        self._content = corrected_expression\r\n\r\n    def _init_check(self, expression: Any, variables_domains: dict = None) -> None:\r\n        self._allowed_types = {}\r\n        self._asserts = [\r\n            (\r\n                not isinstance(expression, str) or Ad.LEFT_IMMUTABLE_BRACKET in expression or re.search(\r\n                    self._allowed_content_pattern, self._replace_immutable_areas(expression)),\r\n                ErrorMessages.MUST_BE_ATOMIC_VARIABLE)\r\n        ]\r\n        super()._init_check(expression)\r\n\r\n    @staticmethod\r\n    def _substitute(alg_exp, variable: str, number: Any):\r\n        super()._substitute(alg_exp, variable, number)\r\n        number_string: str = str(number)\r\n        if isinstance(alg_exp, VariableAtomicAlgExp):\r\n            if alg_exp._content == variable:\r\n                alg_exp._content = number_string\r\n        return alg_exp\r\n\r\n\r\nif __name__ == '__main__':\r\n    while True:\r\n        alg_exp_input: str = input(\": \")\r\n        if alg_exp_input == \"exit\":\r\n            break\r\n        try:\r\n            alg_exp_outer: VariableAtomicAlgExp = VariableAtomicAlgExp(alg_exp_input)\r\n            print(f\"exp: {alg_exp_outer}\")\r\n            print(f\"variables: {alg_exp_outer.variables}\")\r\n            print(f\"variables_domains: {alg_exp_outer.variables_domains}\")\r\n        except Exception as err:\r\n            print(err)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/algexptools/variableatomicalgexp.py b/algexptools/variableatomicalgexp.py
--- a/algexptools/variableatomicalgexp.py	(revision ef16031017abad120dabbe20597ac78a94c54f95)
+++ b/algexptools/variableatomicalgexp.py	(date 1700680256522)
@@ -22,6 +22,9 @@
         self._correction_methods = ()
         VariableAlgExp.__init__(self, expression, variables_domains)
 
+    def is_immutable_content(self):
+        return self._is_wrapped_in_brackets(self._content, Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET)
+
     def _create_content_from_str(self, expression: str) -> None:
         left_imm_br, right_imm_br = Ad.LEFT_IMMUTABLE_BRACKET, Ad.RIGHT_IMMUTABLE_BRACKET
         is_not_atomic: str = ErrorMessages.replace(ErrorMessages.IS_NOT_EXP, expression, AtomicAlgExp.__name__)
